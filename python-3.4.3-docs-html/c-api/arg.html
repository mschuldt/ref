<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Parsing arguments and building values &mdash; Python 3.4.3 documentation</title>
    
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.4.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Python 3.4.3 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python 3.4.3 documentation" href="../index.html" />
    <link rel="up" title="Utilities" href="utilities.html" />
    <link rel="next" title="String conversion and formatting" href="conversion.html" />
    <link rel="prev" title="Data marshalling support" href="marshal.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
 

  </head>
  <body>  
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="conversion.html" title="String conversion and formatting"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="marshal.html" title="Data marshalling support"
             accesskey="P">previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &raquo;</li>
        <li>
          <span class="version_switcher_placeholder">3.4.3</span>
          <a href="../index.html">Documentation</a> &raquo;
        </li>

          <li><a href="index.html" >Python/C API Reference Manual</a> &raquo;</li>
          <li><a href="utilities.html" accesskey="U">Utilities</a> &raquo;</li> 
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="parsing-arguments-and-building-values">
<span id="arg-parsing"></span><h1>Parsing arguments and building values<a class="headerlink" href="#parsing-arguments-and-building-values" title="Permalink to this headline">¶</a></h1>
<p>These functions are useful when creating your own extensions functions and
methods.  Additional information and examples are available in
<a class="reference internal" href="../extending/index.html#extending-index"><em>Extending and Embedding the Python Interpreter</em></a>.</p>
<p>The first three of these functions described, <a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><tt class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple()</span></tt></a>,
<a class="reference internal" href="#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><tt class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTupleAndKeywords()</span></tt></a>, and <a class="reference internal" href="#c.PyArg_Parse" title="PyArg_Parse"><tt class="xref c c-func docutils literal"><span class="pre">PyArg_Parse()</span></tt></a>, all use <em>format
strings</em> which are used to tell the function about the expected arguments.  The
format strings use the same syntax for each of these functions.</p>
<div class="section" id="parsing-arguments">
<h2>Parsing arguments<a class="headerlink" href="#parsing-arguments" title="Permalink to this headline">¶</a></h2>
<p>A format string consists of zero or more &#8220;format units.&#8221;  A format unit
describes one Python object; it is usually a single character or a parenthesized
sequence of format units.  With a few exceptions, a format unit that is not a
parenthesized sequence normally corresponds to a single address argument to
these functions.  In the following description, the quoted form is the format
unit; the entry in (round) parentheses is the Python object type that matches
the format unit; and the entry in [square] brackets is the type of the C
variable(s) whose address should be passed.</p>
<div class="section" id="strings-and-buffers">
<h3>Strings and buffers<a class="headerlink" href="#strings-and-buffers" title="Permalink to this headline">¶</a></h3>
<p>These formats allow to access an object as a contiguous chunk of memory.
You don&#8217;t have to provide raw storage for the returned unicode or bytes
area.  Also, you won&#8217;t have to release any memory yourself, except with the
<tt class="docutils literal"><span class="pre">es</span></tt>, <tt class="docutils literal"><span class="pre">es#</span></tt>, <tt class="docutils literal"><span class="pre">et</span></tt> and <tt class="docutils literal"><span class="pre">et#</span></tt> formats.</p>
<p>However, when a <a class="reference internal" href="buffer.html#c.Py_buffer" title="Py_buffer"><tt class="xref c c-type docutils literal"><span class="pre">Py_buffer</span></tt></a> structure gets filled, the underlying
buffer is locked so that the caller can subsequently use the buffer even
inside a <a class="reference internal" href="init.html#c.Py_BEGIN_ALLOW_THREADS" title="Py_BEGIN_ALLOW_THREADS"><tt class="xref c c-type docutils literal"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></tt></a> block without the risk of mutable data
being resized or destroyed.  As a result, <strong>you have to call</strong>
<a class="reference internal" href="buffer.html#c.PyBuffer_Release" title="PyBuffer_Release"><tt class="xref c c-func docutils literal"><span class="pre">PyBuffer_Release()</span></tt></a> after you have finished processing the data (or
in any early abort case).</p>
<p>Unless otherwise stated, buffers are not NUL-terminated.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For all <tt class="docutils literal"><span class="pre">#</span></tt> variants of formats (<tt class="docutils literal"><span class="pre">s#</span></tt>, <tt class="docutils literal"><span class="pre">y#</span></tt>, etc.), the type of
the length argument (int or <tt class="xref c c-type docutils literal"><span class="pre">Py_ssize_t</span></tt>) is controlled by
defining the macro <tt class="xref c c-macro docutils literal"><span class="pre">PY_SSIZE_T_CLEAN</span></tt> before including
<tt class="file docutils literal"><span class="pre">Python.h</span></tt>.  If the macro was defined, length is a
<tt class="xref c c-type docutils literal"><span class="pre">Py_ssize_t</span></tt> rather than an <tt class="xref c c-type docutils literal"><span class="pre">int</span></tt>. This behavior will change
in a future Python version to only support <tt class="xref c c-type docutils literal"><span class="pre">Py_ssize_t</span></tt> and
drop <tt class="xref c c-type docutils literal"><span class="pre">int</span></tt> support. It is best to always define <tt class="xref c c-macro docutils literal"><span class="pre">PY_SSIZE_T_CLEAN</span></tt>.</p>
</div>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">s</span></tt> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a>) [const char *]</dt>
<dd><p class="first">Convert a Unicode object to a C pointer to a character string.
A pointer to an existing string is stored in the character pointer
variable whose address you pass.  The C string is NUL-terminated.
The Python string must not contain embedded NUL bytes; if it does,
a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> exception is raised. Unicode objects are converted
to C strings using <tt class="docutils literal"><span class="pre">'utf-8'</span></tt> encoding. If this conversion fails, a
<a class="reference internal" href="../library/exceptions.html#UnicodeError" title="UnicodeError"><tt class="xref py py-exc docutils literal"><span class="pre">UnicodeError</span></tt></a> is raised.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This format does not accept <a class="reference internal" href="../glossary.html#term-bytes-like-object"><em class="xref std std-term">bytes-like objects</em></a>.  If you want to accept
filesystem paths and convert them to C character strings, it is
preferable to use the <tt class="docutils literal"><span class="pre">O&amp;</span></tt> format with <a class="reference internal" href="unicode.html#c.PyUnicode_FSConverter" title="PyUnicode_FSConverter"><tt class="xref c c-func docutils literal"><span class="pre">PyUnicode_FSConverter()</span></tt></a>
as <em>converter</em>.</p>
</div>
</dd>
<dt><tt class="docutils literal"><span class="pre">s*</span></tt> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a> or <a class="reference internal" href="../glossary.html#term-bytes-like-object"><em class="xref std std-term">bytes-like object</em></a>) [Py_buffer]</dt>
<dd>This format accepts Unicode objects as well as bytes-like objects.
It fills a <a class="reference internal" href="buffer.html#c.Py_buffer" title="Py_buffer"><tt class="xref c c-type docutils literal"><span class="pre">Py_buffer</span></tt></a> structure provided by the caller.
In this case the resulting C string may contain embedded NUL bytes.
Unicode objects are converted to C strings using <tt class="docutils literal"><span class="pre">'utf-8'</span></tt> encoding.</dd>
<dt><tt class="docutils literal"><span class="pre">s#</span></tt> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a>, read-only <a class="reference internal" href="../glossary.html#term-bytes-like-object"><em class="xref std std-term">bytes-like object</em></a>) [const char *, int or <tt class="xref c c-type docutils literal"><span class="pre">Py_ssize_t</span></tt>]</dt>
<dd>Like <tt class="docutils literal"><span class="pre">s*</span></tt>, except that it doesn&#8217;t accept mutable bytes-like objects
such as <a class="reference internal" href="../library/functions.html#bytearray" title="bytearray"><tt class="xref py py-class docutils literal"><span class="pre">bytearray</span></tt></a>.  The result is stored into two C variables,
the first one a pointer to a C string, the second one its length.
The string may contain embedded null bytes. Unicode objects are converted
to C strings using <tt class="docutils literal"><span class="pre">'utf-8'</span></tt> encoding.</dd>
<dt><tt class="docutils literal"><span class="pre">z</span></tt> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a> or <tt class="docutils literal"><span class="pre">None</span></tt>) [const char *]</dt>
<dd>Like <tt class="docutils literal"><span class="pre">s</span></tt>, but the Python object may also be <tt class="docutils literal"><span class="pre">None</span></tt>, in which case the C
pointer is set to <em>NULL</em>.</dd>
<dt><tt class="docutils literal"><span class="pre">z*</span></tt> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a>, <a class="reference internal" href="../glossary.html#term-bytes-like-object"><em class="xref std std-term">bytes-like object</em></a> or <tt class="docutils literal"><span class="pre">None</span></tt>) [Py_buffer]</dt>
<dd>Like <tt class="docutils literal"><span class="pre">s*</span></tt>, but the Python object may also be <tt class="docutils literal"><span class="pre">None</span></tt>, in which case the
<tt class="docutils literal"><span class="pre">buf</span></tt> member of the <a class="reference internal" href="buffer.html#c.Py_buffer" title="Py_buffer"><tt class="xref c c-type docutils literal"><span class="pre">Py_buffer</span></tt></a> structure is set to <em>NULL</em>.</dd>
<dt><tt class="docutils literal"><span class="pre">z#</span></tt> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a>, read-only <a class="reference internal" href="../glossary.html#term-bytes-like-object"><em class="xref std std-term">bytes-like object</em></a> or <tt class="docutils literal"><span class="pre">None</span></tt>) [const char *, int]</dt>
<dd>Like <tt class="docutils literal"><span class="pre">s#</span></tt>, but the Python object may also be <tt class="docutils literal"><span class="pre">None</span></tt>, in which case the C
pointer is set to <em>NULL</em>.</dd>
<dt><tt class="docutils literal"><span class="pre">y</span></tt> (read-only <a class="reference internal" href="../glossary.html#term-bytes-like-object"><em class="xref std std-term">bytes-like object</em></a>) [const char *]</dt>
<dd>This format converts a bytes-like object to a C pointer to a character
string; it does not accept Unicode objects.  The bytes buffer must not
contain embedded NUL bytes; if it does, a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a>
exception is raised.</dd>
<dt><tt class="docutils literal"><span class="pre">y*</span></tt> (<a class="reference internal" href="../glossary.html#term-bytes-like-object"><em class="xref std std-term">bytes-like object</em></a>) [Py_buffer]</dt>
<dd>This variant on <tt class="docutils literal"><span class="pre">s*</span></tt> doesn&#8217;t accept Unicode objects, only
bytes-like objects.  <strong>This is the recommended way to accept
binary data.</strong></dd>
<dt><tt class="docutils literal"><span class="pre">y#</span></tt> (read-only <a class="reference internal" href="../glossary.html#term-bytes-like-object"><em class="xref std std-term">bytes-like object</em></a>) [const char *, int]</dt>
<dd>This variant on <tt class="docutils literal"><span class="pre">s#</span></tt> doesn&#8217;t accept Unicode objects, only bytes-like
objects.</dd>
<dt><tt class="docutils literal"><span class="pre">S</span></tt> (<a class="reference internal" href="../library/functions.html#bytes" title="bytes"><tt class="xref py py-class docutils literal"><span class="pre">bytes</span></tt></a>) [PyBytesObject *]</dt>
<dd>Requires that the Python object is a <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><tt class="xref py py-class docutils literal"><span class="pre">bytes</span></tt></a> object, without
attempting any conversion.  Raises <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> if the object is not
a bytes object.  The C variable may also be declared as <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><tt class="xref c c-type docutils literal"><span class="pre">PyObject*</span></tt></a>.</dd>
<dt><tt class="docutils literal"><span class="pre">Y</span></tt> (<a class="reference internal" href="../library/functions.html#bytearray" title="bytearray"><tt class="xref py py-class docutils literal"><span class="pre">bytearray</span></tt></a>) [PyByteArrayObject *]</dt>
<dd>Requires that the Python object is a <a class="reference internal" href="../library/functions.html#bytearray" title="bytearray"><tt class="xref py py-class docutils literal"><span class="pre">bytearray</span></tt></a> object, without
attempting any conversion.  Raises <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> if the object is not
a <a class="reference internal" href="../library/functions.html#bytearray" title="bytearray"><tt class="xref py py-class docutils literal"><span class="pre">bytearray</span></tt></a> object. The C variable may also be declared as <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><tt class="xref c c-type docutils literal"><span class="pre">PyObject*</span></tt></a>.</dd>
<dt><tt class="docutils literal"><span class="pre">u</span></tt> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a>) [Py_UNICODE *]</dt>
<dd><p class="first">Convert a Python Unicode object to a C pointer to a NUL-terminated buffer of
Unicode characters.  You must pass the address of a <a class="reference internal" href="unicode.html#c.Py_UNICODE" title="Py_UNICODE"><tt class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></tt></a>
pointer variable, which will be filled with the pointer to an existing
Unicode buffer.  Please note that the width of a <a class="reference internal" href="unicode.html#c.Py_UNICODE" title="Py_UNICODE"><tt class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></tt></a>
character depends on compilation options (it is either 16 or 32 bits).
The Python string must not contain embedded NUL characters; if it does,
a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> exception is raised.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Since <tt class="docutils literal"><span class="pre">u</span></tt> doesn&#8217;t give you back the length of the string, and it
may contain embedded NUL characters, it is recommended to use <tt class="docutils literal"><span class="pre">u#</span></tt>
or <tt class="docutils literal"><span class="pre">U</span></tt> instead.</p>
</div>
</dd>
<dt><tt class="docutils literal"><span class="pre">u#</span></tt> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a>) [Py_UNICODE *, int]</dt>
<dd>This variant on <tt class="docutils literal"><span class="pre">u</span></tt> stores into two C variables, the first one a pointer to a
Unicode data buffer, the second one its length.</dd>
<dt><tt class="docutils literal"><span class="pre">Z</span></tt> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a> or <tt class="docutils literal"><span class="pre">None</span></tt>) [Py_UNICODE *]</dt>
<dd>Like <tt class="docutils literal"><span class="pre">u</span></tt>, but the Python object may also be <tt class="docutils literal"><span class="pre">None</span></tt>, in which case the
<a class="reference internal" href="unicode.html#c.Py_UNICODE" title="Py_UNICODE"><tt class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></tt></a> pointer is set to <em>NULL</em>.</dd>
<dt><tt class="docutils literal"><span class="pre">Z#</span></tt> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a> or <tt class="docutils literal"><span class="pre">None</span></tt>) [Py_UNICODE *, int]</dt>
<dd>Like <tt class="docutils literal"><span class="pre">u#</span></tt>, but the Python object may also be <tt class="docutils literal"><span class="pre">None</span></tt>, in which case the
<a class="reference internal" href="unicode.html#c.Py_UNICODE" title="Py_UNICODE"><tt class="xref c c-type docutils literal"><span class="pre">Py_UNICODE</span></tt></a> pointer is set to <em>NULL</em>.</dd>
<dt><tt class="docutils literal"><span class="pre">U</span></tt> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a>) [PyObject *]</dt>
<dd>Requires that the Python object is a Unicode object, without attempting
any conversion.  Raises <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> if the object is not a Unicode
object.  The C variable may also be declared as <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><tt class="xref c c-type docutils literal"><span class="pre">PyObject*</span></tt></a>.</dd>
<dt><tt class="docutils literal"><span class="pre">w*</span></tt> (<a class="reference internal" href="../library/functions.html#bytearray" title="bytearray"><tt class="xref py py-class docutils literal"><span class="pre">bytearray</span></tt></a> or read-write byte-oriented buffer) [Py_buffer]</dt>
<dd>This format accepts any object which implements the read-write buffer
interface. It fills a <a class="reference internal" href="buffer.html#c.Py_buffer" title="Py_buffer"><tt class="xref c c-type docutils literal"><span class="pre">Py_buffer</span></tt></a> structure provided by the caller.
The buffer may contain embedded null bytes. The caller have to call
<a class="reference internal" href="buffer.html#c.PyBuffer_Release" title="PyBuffer_Release"><tt class="xref c c-func docutils literal"><span class="pre">PyBuffer_Release()</span></tt></a> when it is done with the buffer.</dd>
<dt><tt class="docutils literal"><span class="pre">es</span></tt> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a>) [const char *encoding, char **buffer]</dt>
<dd><p class="first">This variant on <tt class="docutils literal"><span class="pre">s</span></tt> is used for encoding Unicode into a character buffer.
It only works for encoded data without embedded NUL bytes.</p>
<p>This format requires two arguments.  The first is only used as input, and
must be a <tt class="xref c c-type docutils literal"><span class="pre">const</span> <span class="pre">char*</span></tt> which points to the name of an encoding as a
NUL-terminated string, or <em>NULL</em>, in which case <tt class="docutils literal"><span class="pre">'utf-8'</span></tt> encoding is used.
An exception is raised if the named encoding is not known to Python.  The
second argument must be a <tt class="xref c c-type docutils literal"><span class="pre">char**</span></tt>; the value of the pointer it
references will be set to a buffer with the contents of the argument text.
The text will be encoded in the encoding specified by the first argument.</p>
<p class="last"><a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><tt class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple()</span></tt></a> will allocate a buffer of the needed size, copy the
encoded data into this buffer and adjust <em>*buffer</em> to reference the newly
allocated storage.  The caller is responsible for calling <a class="reference internal" href="memory.html#c.PyMem_Free" title="PyMem_Free"><tt class="xref c c-func docutils literal"><span class="pre">PyMem_Free()</span></tt></a> to
free the allocated buffer after use.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">et</span></tt> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a>, <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><tt class="xref py py-class docutils literal"><span class="pre">bytes</span></tt></a> or <a class="reference internal" href="../library/functions.html#bytearray" title="bytearray"><tt class="xref py py-class docutils literal"><span class="pre">bytearray</span></tt></a>) [const char *encoding, char **buffer]</dt>
<dd>Same as <tt class="docutils literal"><span class="pre">es</span></tt> except that byte string objects are passed through without
recoding them.  Instead, the implementation assumes that the byte string object uses
the encoding passed in as parameter.</dd>
<dt><tt class="docutils literal"><span class="pre">es#</span></tt> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a>) [const char *encoding, char **buffer, int *buffer_length]</dt>
<dd><p class="first">This variant on <tt class="docutils literal"><span class="pre">s#</span></tt> is used for encoding Unicode into a character buffer.
Unlike the <tt class="docutils literal"><span class="pre">es</span></tt> format, this variant allows input data which contains NUL
characters.</p>
<p>It requires three arguments.  The first is only used as input, and must be a
<tt class="xref c c-type docutils literal"><span class="pre">const</span> <span class="pre">char*</span></tt> which points to the name of an encoding as a
NUL-terminated string, or <em>NULL</em>, in which case <tt class="docutils literal"><span class="pre">'utf-8'</span></tt> encoding is used.
An exception is raised if the named encoding is not known to Python.  The
second argument must be a <tt class="xref c c-type docutils literal"><span class="pre">char**</span></tt>; the value of the pointer it
references will be set to a buffer with the contents of the argument text.
The text will be encoded in the encoding specified by the first argument.
The third argument must be a pointer to an integer; the referenced integer
will be set to the number of bytes in the output buffer.</p>
<p>There are two modes of operation:</p>
<p>If <em>*buffer</em> points a <em>NULL</em> pointer, the function will allocate a buffer of
the needed size, copy the encoded data into this buffer and set <em>*buffer</em> to
reference the newly allocated storage.  The caller is responsible for calling
<a class="reference internal" href="memory.html#c.PyMem_Free" title="PyMem_Free"><tt class="xref c c-func docutils literal"><span class="pre">PyMem_Free()</span></tt></a> to free the allocated buffer after usage.</p>
<p>If <em>*buffer</em> points to a non-<em>NULL</em> pointer (an already allocated buffer),
<a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><tt class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple()</span></tt></a> will use this location as the buffer and interpret the
initial value of <em>*buffer_length</em> as the buffer size.  It will then copy the
encoded data into the buffer and NUL-terminate it.  If the buffer is not large
enough, a <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> will be set.</p>
<p class="last">In both cases, <em>*buffer_length</em> is set to the length of the encoded data
without the trailing NUL byte.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">et#</span></tt> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a>, <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><tt class="xref py py-class docutils literal"><span class="pre">bytes</span></tt></a> or <a class="reference internal" href="../library/functions.html#bytearray" title="bytearray"><tt class="xref py py-class docutils literal"><span class="pre">bytearray</span></tt></a>) [const char *encoding, char **buffer, int *buffer_length]</dt>
<dd>Same as <tt class="docutils literal"><span class="pre">es#</span></tt> except that byte string objects are passed through without recoding
them. Instead, the implementation assumes that the byte string object uses the
encoding passed in as parameter.</dd>
</dl>
</div>
<div class="section" id="numbers">
<h3>Numbers<a class="headerlink" href="#numbers" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">b</span></tt> (<a class="reference internal" href="../library/functions.html#int" title="int"><tt class="xref py py-class docutils literal"><span class="pre">int</span></tt></a>) [unsigned char]</dt>
<dd>Convert a nonnegative Python integer to an unsigned tiny int, stored in a C
<tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">B</span></tt> (<a class="reference internal" href="../library/functions.html#int" title="int"><tt class="xref py py-class docutils literal"><span class="pre">int</span></tt></a>) [unsigned char]</dt>
<dd>Convert a Python integer to a tiny int without overflow checking, stored in a C
<tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">h</span></tt> (<a class="reference internal" href="../library/functions.html#int" title="int"><tt class="xref py py-class docutils literal"><span class="pre">int</span></tt></a>) [short int]</dt>
<dd>Convert a Python integer to a C <tt class="xref c c-type docutils literal"><span class="pre">short</span> <span class="pre">int</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">H</span></tt> (<a class="reference internal" href="../library/functions.html#int" title="int"><tt class="xref py py-class docutils literal"><span class="pre">int</span></tt></a>) [unsigned short int]</dt>
<dd>Convert a Python integer to a C <tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">int</span></tt>, without overflow
checking.</dd>
<dt><tt class="docutils literal"><span class="pre">i</span></tt> (<a class="reference internal" href="../library/functions.html#int" title="int"><tt class="xref py py-class docutils literal"><span class="pre">int</span></tt></a>) [int]</dt>
<dd>Convert a Python integer to a plain C <tt class="xref c c-type docutils literal"><span class="pre">int</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">I</span></tt> (<a class="reference internal" href="../library/functions.html#int" title="int"><tt class="xref py py-class docutils literal"><span class="pre">int</span></tt></a>) [unsigned int]</dt>
<dd>Convert a Python integer to a C <tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span></tt>, without overflow
checking.</dd>
<dt><tt class="docutils literal"><span class="pre">l</span></tt> (<a class="reference internal" href="../library/functions.html#int" title="int"><tt class="xref py py-class docutils literal"><span class="pre">int</span></tt></a>) [long int]</dt>
<dd>Convert a Python integer to a C <tt class="xref c c-type docutils literal"><span class="pre">long</span> <span class="pre">int</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">k</span></tt> (<a class="reference internal" href="../library/functions.html#int" title="int"><tt class="xref py py-class docutils literal"><span class="pre">int</span></tt></a>) [unsigned long]</dt>
<dd>Convert a Python integer to a C <tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span></tt> without
overflow checking.</dd>
<dt><tt class="docutils literal"><span class="pre">L</span></tt> (<a class="reference internal" href="../library/functions.html#int" title="int"><tt class="xref py py-class docutils literal"><span class="pre">int</span></tt></a>) [PY_LONG_LONG]</dt>
<dd>Convert a Python integer to a C <tt class="xref c c-type docutils literal"><span class="pre">long</span> <span class="pre">long</span></tt>.  This format is only
available on platforms that support <tt class="xref c c-type docutils literal"><span class="pre">long</span> <span class="pre">long</span></tt> (or <tt class="xref c c-type docutils literal"><span class="pre">_int64</span></tt> on
Windows).</dd>
<dt><tt class="docutils literal"><span class="pre">K</span></tt> (<a class="reference internal" href="../library/functions.html#int" title="int"><tt class="xref py py-class docutils literal"><span class="pre">int</span></tt></a>) [unsigned PY_LONG_LONG]</dt>
<dd>Convert a Python integer to a C <tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></tt>
without overflow checking.  This format is only available on platforms that
support <tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></tt> (or <tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">_int64</span></tt> on Windows).</dd>
<dt><tt class="docutils literal"><span class="pre">n</span></tt> (<a class="reference internal" href="../library/functions.html#int" title="int"><tt class="xref py py-class docutils literal"><span class="pre">int</span></tt></a>) [Py_ssize_t]</dt>
<dd>Convert a Python integer to a C <tt class="xref c c-type docutils literal"><span class="pre">Py_ssize_t</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">c</span></tt> (<a class="reference internal" href="../library/functions.html#bytes" title="bytes"><tt class="xref py py-class docutils literal"><span class="pre">bytes</span></tt></a> or <a class="reference internal" href="../library/functions.html#bytearray" title="bytearray"><tt class="xref py py-class docutils literal"><span class="pre">bytearray</span></tt></a> of length 1) [char]</dt>
<dd><p class="first">Convert a Python byte, represented as a <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><tt class="xref py py-class docutils literal"><span class="pre">bytes</span></tt></a> or
<a class="reference internal" href="../library/functions.html#bytearray" title="bytearray"><tt class="xref py py-class docutils literal"><span class="pre">bytearray</span></tt></a> object of length 1, to a C <tt class="xref c c-type docutils literal"><span class="pre">char</span></tt>.</p>
<div class="last versionchanged">
<p><span class="versionmodified">Changed in version 3.3: </span>Allow <a class="reference internal" href="../library/functions.html#bytearray" title="bytearray"><tt class="xref py py-class docutils literal"><span class="pre">bytearray</span></tt></a> objects.</p>
</div>
</dd>
<dt><tt class="docutils literal"><span class="pre">C</span></tt> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a> of length 1) [int]</dt>
<dd>Convert a Python character, represented as a <a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a> object of
length 1, to a C <tt class="xref c c-type docutils literal"><span class="pre">int</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">f</span></tt> (<a class="reference internal" href="../library/functions.html#float" title="float"><tt class="xref py py-class docutils literal"><span class="pre">float</span></tt></a>) [float]</dt>
<dd>Convert a Python floating point number to a C <tt class="xref c c-type docutils literal"><span class="pre">float</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">d</span></tt> (<a class="reference internal" href="../library/functions.html#float" title="float"><tt class="xref py py-class docutils literal"><span class="pre">float</span></tt></a>) [double]</dt>
<dd>Convert a Python floating point number to a C <tt class="xref c c-type docutils literal"><span class="pre">double</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">D</span></tt> (<a class="reference internal" href="../library/functions.html#complex" title="complex"><tt class="xref py py-class docutils literal"><span class="pre">complex</span></tt></a>) [Py_complex]</dt>
<dd>Convert a Python complex number to a C <a class="reference internal" href="complex.html#c.Py_complex" title="Py_complex"><tt class="xref c c-type docutils literal"><span class="pre">Py_complex</span></tt></a> structure.</dd>
</dl>
</div>
<div class="section" id="other-objects">
<h3>Other objects<a class="headerlink" href="#other-objects" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">O</span></tt> (object) [PyObject *]</dt>
<dd>Store a Python object (without any conversion) in a C object pointer.  The C
program thus receives the actual object that was passed.  The object&#8217;s reference
count is not increased.  The pointer stored is not <em>NULL</em>.</dd>
<dt><tt class="docutils literal"><span class="pre">O!</span></tt> (object) [<em>typeobject</em>, PyObject *]</dt>
<dd>Store a Python object in a C object pointer.  This is similar to <tt class="docutils literal"><span class="pre">O</span></tt>, but
takes two C arguments: the first is the address of a Python type object, the
second is the address of the C variable (of type <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><tt class="xref c c-type docutils literal"><span class="pre">PyObject*</span></tt></a>) into which
the object pointer is stored.  If the Python object does not have the required
type, <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt></a> is raised.</dd>
</dl>
<dl class="docutils" id="o-ampersand">
<dt><tt class="docutils literal"><span class="pre">O&amp;</span></tt> (object) [<em>converter</em>, <em>anything</em>]</dt>
<dd><p class="first">Convert a Python object to a C variable through a <em>converter</em> function.  This
takes two arguments: the first is a function, the second is the address of a C
variable (of arbitrary type), converted to <tt class="xref c c-type docutils literal"><span class="pre">void</span> <span class="pre">*</span></tt>.  The <em>converter</em>
function in turn is called as follows:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">status</span> <span class="o">=</span> <span class="n">converter</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
</pre></div>
</div>
<p>where <em>object</em> is the Python object to be converted and <em>address</em> is the
<tt class="xref c c-type docutils literal"><span class="pre">void*</span></tt> argument that was passed to the <a class="reference internal" href="#c.PyArg_Parse" title="PyArg_Parse"><tt class="xref c c-func docutils literal"><span class="pre">PyArg_Parse*()</span></tt></a> function.
The returned <em>status</em> should be <tt class="docutils literal"><span class="pre">1</span></tt> for a successful conversion and <tt class="docutils literal"><span class="pre">0</span></tt> if
the conversion has failed.  When the conversion fails, the <em>converter</em> function
should raise an exception and leave the content of <em>address</em> unmodified.</p>
<p>If the <em>converter</em> returns <tt class="docutils literal"><span class="pre">Py_CLEANUP_SUPPORTED</span></tt>, it may get called a
second time if the argument parsing eventually fails, giving the converter a
chance to release any memory that it had already allocated. In this second
call, the <em>object</em> parameter will be NULL; <em>address</em> will have the same value
as in the original call.</p>
<div class="last versionchanged">
<p><span class="versionmodified">Changed in version 3.1: </span><tt class="docutils literal"><span class="pre">Py_CLEANUP_SUPPORTED</span></tt> was added.</p>
</div>
</dd>
<dt><tt class="docutils literal"><span class="pre">p</span></tt> (<a class="reference internal" href="../library/functions.html#bool" title="bool"><tt class="xref py py-class docutils literal"><span class="pre">bool</span></tt></a>) [int]</dt>
<dd><p class="first">Tests the value passed in for truth (a boolean <strong>p</strong>redicate) and converts
the result to its equivalent C true/false integer value.
Sets the int to 1 if the expression was true and 0 if it was false.
This accepts any valid Python value.  See <a class="reference internal" href="../library/stdtypes.html#truth"><em>Truth Value Testing</em></a> for more
information about how Python tests values for truth.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 3.3.</span></p>
</div>
</dd>
<dt><tt class="docutils literal"><span class="pre">(items)</span></tt> (<a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><tt class="xref py py-class docutils literal"><span class="pre">tuple</span></tt></a>) [<em>matching-items</em>]</dt>
<dd>The object must be a Python sequence whose length is the number of format units
in <em>items</em>.  The C arguments must correspond to the individual format units in
<em>items</em>.  Format units for sequences may be nested.</dd>
</dl>
<p>It is possible to pass &#8220;long&#8221; integers (integers whose value exceeds the
platform&#8217;s <tt class="xref py py-const docutils literal"><span class="pre">LONG_MAX</span></tt>) however no proper range checking is done &#8212; the
most significant bits are silently truncated when the receiving field is too
small to receive the value (actually, the semantics are inherited from downcasts
in C &#8212; your mileage may vary).</p>
<p>A few other characters have a meaning in a format string.  These may not occur
inside nested parentheses.  They are:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">|</span></tt></dt>
<dd>Indicates that the remaining arguments in the Python argument list are optional.
The C variables corresponding to optional arguments should be initialized to
their default value &#8212; when an optional argument is not specified,
<a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><tt class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple()</span></tt></a> does not touch the contents of the corresponding C
variable(s).</dd>
<dt><tt class="docutils literal"><span class="pre">$</span></tt></dt>
<dd><p class="first"><a class="reference internal" href="#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><tt class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTupleAndKeywords()</span></tt></a> only:
Indicates that the remaining arguments in the Python argument list are
keyword-only.  Currently, all keyword-only arguments must also be optional
arguments, so <tt class="docutils literal"><span class="pre">|</span></tt> must always be specified before <tt class="docutils literal"><span class="pre">$</span></tt> in the format
string.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 3.3.</span></p>
</div>
</dd>
<dt><tt class="docutils literal"><span class="pre">:</span></tt></dt>
<dd>The list of format units ends here; the string after the colon is used as the
function name in error messages (the &#8220;associated value&#8221; of the exception that
<a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><tt class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple()</span></tt></a> raises).</dd>
<dt><tt class="docutils literal"><span class="pre">;</span></tt></dt>
<dd>The list of format units ends here; the string after the semicolon is used as
the error message <em>instead</em> of the default error message.  <tt class="docutils literal"><span class="pre">:</span></tt> and <tt class="docutils literal"><span class="pre">;</span></tt>
mutually exclude each other.</dd>
</dl>
<p>Note that any Python object references which are provided to the caller are
<em>borrowed</em> references; do not decrement their reference count!</p>
<p>Additional arguments passed to these functions must be addresses of variables
whose type is determined by the format string; these are used to store values
from the input tuple.  There are a few cases, as described in the list of format
units above, where these parameters are used as input values; they should match
what is specified for the corresponding format unit in that case.</p>
<p>For the conversion to succeed, the <em>arg</em> object must match the format
and the format must be exhausted.  On success, the
<a class="reference internal" href="#c.PyArg_Parse" title="PyArg_Parse"><tt class="xref c c-func docutils literal"><span class="pre">PyArg_Parse*()</span></tt></a> functions return true, otherwise they return
false and raise an appropriate exception. When the
<a class="reference internal" href="#c.PyArg_Parse" title="PyArg_Parse"><tt class="xref c c-func docutils literal"><span class="pre">PyArg_Parse*()</span></tt></a> functions fail due to conversion failure in one
of the format units, the variables at the addresses corresponding to that
and the following format units are left untouched.</p>
</div>
<div class="section" id="api-functions">
<h3>API Functions<a class="headerlink" href="#api-functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.PyArg_ParseTuple">
int <tt class="descname">PyArg_ParseTuple</tt><big>(</big><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*args</em>, const char<em>&nbsp;*format</em>, ...<big>)</big><a class="headerlink" href="#c.PyArg_ParseTuple" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse the parameters of a function that takes only positional parameters into
local variables.  Returns true on success; on failure, it returns false and
raises the appropriate exception.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyArg_VaParse">
int <tt class="descname">PyArg_VaParse</tt><big>(</big><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*args</em>, const char<em>&nbsp;*format</em>, va_list<em>&nbsp;vargs</em><big>)</big><a class="headerlink" href="#c.PyArg_VaParse" title="Permalink to this definition">¶</a></dt>
<dd><p>Identical to <a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><tt class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple()</span></tt></a>, except that it accepts a va_list rather
than a variable number of arguments.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyArg_ParseTupleAndKeywords">
int <tt class="descname">PyArg_ParseTupleAndKeywords</tt><big>(</big><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*args</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*kw</em>, const char<em>&nbsp;*format</em>, char<em>&nbsp;*keywords[]</em>, ...<big>)</big><a class="headerlink" href="#c.PyArg_ParseTupleAndKeywords" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse the parameters of a function that takes both positional and keyword
parameters into local variables.  Returns true on success; on failure, it
returns false and raises the appropriate exception.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyArg_VaParseTupleAndKeywords">
int <tt class="descname">PyArg_VaParseTupleAndKeywords</tt><big>(</big><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*args</em>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*kw</em>, const char<em>&nbsp;*format</em>, char<em>&nbsp;*keywords[]</em>, va_list<em>&nbsp;vargs</em><big>)</big><a class="headerlink" href="#c.PyArg_VaParseTupleAndKeywords" title="Permalink to this definition">¶</a></dt>
<dd><p>Identical to <a class="reference internal" href="#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><tt class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTupleAndKeywords()</span></tt></a>, except that it accepts a
va_list rather than a variable number of arguments.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyArg_ValidateKeywordArguments">
int <tt class="descname">PyArg_ValidateKeywordArguments</tt><big>(</big><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*</em><big>)</big><a class="headerlink" href="#c.PyArg_ValidateKeywordArguments" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that the keys in the keywords argument dictionary are strings.  This
is only needed if <a class="reference internal" href="#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><tt class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTupleAndKeywords()</span></tt></a> is not used, since the
latter already does this check.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyArg_Parse">
int <tt class="descname">PyArg_Parse</tt><big>(</big><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*args</em>, const char<em>&nbsp;*format</em>, ...<big>)</big><a class="headerlink" href="#c.PyArg_Parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Function used to deconstruct the argument lists of &#8220;old-style&#8221; functions &#8212;
these are functions which use the <tt class="xref py py-const docutils literal"><span class="pre">METH_OLDARGS</span></tt> parameter parsing
method, which has been removed in Python 3.  This is not recommended for use
in parameter parsing in new code, and most code in the standard interpreter
has been modified to no longer use this for that purpose.  It does remain a
convenient way to decompose other tuples, however, and may continue to be
used for that purpose.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyArg_UnpackTuple">
int <tt class="descname">PyArg_UnpackTuple</tt><big>(</big><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*args</em>, const char<em>&nbsp;*name</em>, Py_ssize_t<em>&nbsp;min</em>, Py_ssize_t<em>&nbsp;max</em>, ...<big>)</big><a class="headerlink" href="#c.PyArg_UnpackTuple" title="Permalink to this definition">¶</a></dt>
<dd><p>A simpler form of parameter retrieval which does not use a format string to
specify the types of the arguments.  Functions which use this method to retrieve
their parameters should be declared as <a class="reference internal" href="structures.html#METH_VARARGS" title="METH_VARARGS"><tt class="xref py py-const docutils literal"><span class="pre">METH_VARARGS</span></tt></a> in function or
method tables.  The tuple containing the actual parameters should be passed as
<em>args</em>; it must actually be a tuple.  The length of the tuple must be at least
<em>min</em> and no more than <em>max</em>; <em>min</em> and <em>max</em> may be equal.  Additional
arguments must be passed to the function, each of which should be a pointer to a
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><tt class="xref c c-type docutils literal"><span class="pre">PyObject*</span></tt></a> variable; these will be filled in with the values from
<em>args</em>; they will contain borrowed references.  The variables which correspond
to optional parameters not given by <em>args</em> will not be filled in; these should
be initialized by the caller. This function returns true on success and false if
<em>args</em> is not a tuple or contains the wrong number of elements; an exception
will be set if there was a failure.</p>
<p>This is an example of the use of this function, taken from the sources for the
<tt class="xref py py-mod docutils literal"><span class="pre">_weakref</span></tt> helper module for weak references:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">weakref_ref</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">callback</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">PyArg_UnpackTuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="s">&quot;ref&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">callback</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">PyWeakref_NewRef</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">callback</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The call to <a class="reference internal" href="#c.PyArg_UnpackTuple" title="PyArg_UnpackTuple"><tt class="xref c c-func docutils literal"><span class="pre">PyArg_UnpackTuple()</span></tt></a> in this example is entirely equivalent to
this call to <a class="reference internal" href="#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><tt class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple()</span></tt></a>:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">PyArg_ParseTuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="s">&quot;O|O:ref&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">object</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">callback</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="building-values">
<h2>Building values<a class="headerlink" href="#building-values" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.Py_BuildValue">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <tt class="descname">Py_BuildValue</tt><big>(</big>const char<em>&nbsp;*format</em>, ...<big>)</big><a class="headerlink" href="#c.Py_BuildValue" title="Permalink to this definition">¶</a></dt>
<dd><em class="refcount">Return value: New reference.</em><p>Create a new value based on a format string similar to those accepted by the
<a class="reference internal" href="#c.PyArg_Parse" title="PyArg_Parse"><tt class="xref c c-func docutils literal"><span class="pre">PyArg_Parse*()</span></tt></a> family of functions and a sequence of values.  Returns
the value or <em>NULL</em> in the case of an error; an exception will be raised if
<em>NULL</em> is returned.</p>
<p><a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><tt class="xref c c-func docutils literal"><span class="pre">Py_BuildValue()</span></tt></a> does not always build a tuple.  It builds a tuple only if
its format string contains two or more format units.  If the format string is
empty, it returns <tt class="docutils literal"><span class="pre">None</span></tt>; if it contains exactly one format unit, it returns
whatever object is described by that format unit.  To force it to return a tuple
of size 0 or one, parenthesize the format string.</p>
<p>When memory buffers are passed as parameters to supply data to build objects, as
for the <tt class="docutils literal"><span class="pre">s</span></tt> and <tt class="docutils literal"><span class="pre">s#</span></tt> formats, the required data is copied.  Buffers provided
by the caller are never referenced by the objects created by
<a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><tt class="xref c c-func docutils literal"><span class="pre">Py_BuildValue()</span></tt></a>.  In other words, if your code invokes <tt class="xref c c-func docutils literal"><span class="pre">malloc()</span></tt>
and passes the allocated memory to <a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><tt class="xref c c-func docutils literal"><span class="pre">Py_BuildValue()</span></tt></a>, your code is
responsible for calling <tt class="xref c c-func docutils literal"><span class="pre">free()</span></tt> for that memory once
<a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><tt class="xref c c-func docutils literal"><span class="pre">Py_BuildValue()</span></tt></a> returns.</p>
<p>In the following description, the quoted form is the format unit; the entry in
(round) parentheses is the Python object type that the format unit will return;
and the entry in [square] brackets is the type of the C value(s) to be passed.</p>
<p>The characters space, tab, colon and comma are ignored in format strings (but
not within format units such as <tt class="docutils literal"><span class="pre">s#</span></tt>).  This can be used to make long format
strings a tad more readable.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">s</span></tt> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a> or <tt class="docutils literal"><span class="pre">None</span></tt>) [char *]</dt>
<dd>Convert a null-terminated C string to a Python <a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a> object using <tt class="docutils literal"><span class="pre">'utf-8'</span></tt>
encoding. If the C string pointer is <em>NULL</em>, <tt class="docutils literal"><span class="pre">None</span></tt> is used.</dd>
<dt><tt class="docutils literal"><span class="pre">s#</span></tt> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a> or <tt class="docutils literal"><span class="pre">None</span></tt>) [char *, int]</dt>
<dd>Convert a C string and its length to a Python <a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a> object using <tt class="docutils literal"><span class="pre">'utf-8'</span></tt>
encoding. If the C string pointer is <em>NULL</em>, the length is ignored and
<tt class="docutils literal"><span class="pre">None</span></tt> is returned.</dd>
<dt><tt class="docutils literal"><span class="pre">y</span></tt> (<a class="reference internal" href="../library/functions.html#bytes" title="bytes"><tt class="xref py py-class docutils literal"><span class="pre">bytes</span></tt></a>) [char *]</dt>
<dd>This converts a C string to a Python <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><tt class="xref py py-class docutils literal"><span class="pre">bytes</span></tt></a> object.  If the C
string pointer is <em>NULL</em>, <tt class="docutils literal"><span class="pre">None</span></tt> is returned.</dd>
<dt><tt class="docutils literal"><span class="pre">y#</span></tt> (<a class="reference internal" href="../library/functions.html#bytes" title="bytes"><tt class="xref py py-class docutils literal"><span class="pre">bytes</span></tt></a>) [char *, int]</dt>
<dd>This converts a C string and its lengths to a Python object.  If the C
string pointer is <em>NULL</em>, <tt class="docutils literal"><span class="pre">None</span></tt> is returned.</dd>
<dt><tt class="docutils literal"><span class="pre">z</span></tt> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a> or <tt class="docutils literal"><span class="pre">None</span></tt>) [char *]</dt>
<dd>Same as <tt class="docutils literal"><span class="pre">s</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">z#</span></tt> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a> or <tt class="docutils literal"><span class="pre">None</span></tt>) [char *, int]</dt>
<dd>Same as <tt class="docutils literal"><span class="pre">s#</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">u</span></tt> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a>) [Py_UNICODE *]</dt>
<dd>Convert a null-terminated buffer of Unicode (UCS-2 or UCS-4) data to a Python
Unicode object.  If the Unicode buffer pointer is <em>NULL</em>, <tt class="docutils literal"><span class="pre">None</span></tt> is returned.</dd>
<dt><tt class="docutils literal"><span class="pre">u#</span></tt> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a>) [Py_UNICODE *, int]</dt>
<dd>Convert a Unicode (UCS-2 or UCS-4) data buffer and its length to a Python
Unicode object.   If the Unicode buffer pointer is <em>NULL</em>, the length is ignored
and <tt class="docutils literal"><span class="pre">None</span></tt> is returned.</dd>
<dt><tt class="docutils literal"><span class="pre">U</span></tt> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a> or <tt class="docutils literal"><span class="pre">None</span></tt>) [char *]</dt>
<dd>Same as <tt class="docutils literal"><span class="pre">s</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">U#</span></tt> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a> or <tt class="docutils literal"><span class="pre">None</span></tt>) [char *, int]</dt>
<dd>Same as <tt class="docutils literal"><span class="pre">s#</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">i</span></tt> (<a class="reference internal" href="../library/functions.html#int" title="int"><tt class="xref py py-class docutils literal"><span class="pre">int</span></tt></a>) [int]</dt>
<dd>Convert a plain C <tt class="xref c c-type docutils literal"><span class="pre">int</span></tt> to a Python integer object.</dd>
<dt><tt class="docutils literal"><span class="pre">b</span></tt> (<a class="reference internal" href="../library/functions.html#int" title="int"><tt class="xref py py-class docutils literal"><span class="pre">int</span></tt></a>) [char]</dt>
<dd>Convert a plain C <tt class="xref c c-type docutils literal"><span class="pre">char</span></tt> to a Python integer object.</dd>
<dt><tt class="docutils literal"><span class="pre">h</span></tt> (<a class="reference internal" href="../library/functions.html#int" title="int"><tt class="xref py py-class docutils literal"><span class="pre">int</span></tt></a>) [short int]</dt>
<dd>Convert a plain C <tt class="xref c c-type docutils literal"><span class="pre">short</span> <span class="pre">int</span></tt> to a Python integer object.</dd>
<dt><tt class="docutils literal"><span class="pre">l</span></tt> (<a class="reference internal" href="../library/functions.html#int" title="int"><tt class="xref py py-class docutils literal"><span class="pre">int</span></tt></a>) [long int]</dt>
<dd>Convert a C <tt class="xref c c-type docutils literal"><span class="pre">long</span> <span class="pre">int</span></tt> to a Python integer object.</dd>
<dt><tt class="docutils literal"><span class="pre">B</span></tt> (<a class="reference internal" href="../library/functions.html#int" title="int"><tt class="xref py py-class docutils literal"><span class="pre">int</span></tt></a>) [unsigned char]</dt>
<dd>Convert a C <tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span></tt> to a Python integer object.</dd>
<dt><tt class="docutils literal"><span class="pre">H</span></tt> (<a class="reference internal" href="../library/functions.html#int" title="int"><tt class="xref py py-class docutils literal"><span class="pre">int</span></tt></a>) [unsigned short int]</dt>
<dd>Convert a C <tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">int</span></tt> to a Python integer object.</dd>
<dt><tt class="docutils literal"><span class="pre">I</span></tt> (<a class="reference internal" href="../library/functions.html#int" title="int"><tt class="xref py py-class docutils literal"><span class="pre">int</span></tt></a>) [unsigned int]</dt>
<dd>Convert a C <tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span></tt> to a Python integer object.</dd>
<dt><tt class="docutils literal"><span class="pre">k</span></tt> (<a class="reference internal" href="../library/functions.html#int" title="int"><tt class="xref py py-class docutils literal"><span class="pre">int</span></tt></a>) [unsigned long]</dt>
<dd>Convert a C <tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span></tt> to a Python integer object.</dd>
<dt><tt class="docutils literal"><span class="pre">L</span></tt> (<a class="reference internal" href="../library/functions.html#int" title="int"><tt class="xref py py-class docutils literal"><span class="pre">int</span></tt></a>) [PY_LONG_LONG]</dt>
<dd>Convert a C <tt class="xref c c-type docutils literal"><span class="pre">long</span> <span class="pre">long</span></tt> to a Python integer object. Only available
on platforms that support <tt class="xref c c-type docutils literal"><span class="pre">long</span> <span class="pre">long</span></tt> (or <tt class="xref c c-type docutils literal"><span class="pre">_int64</span></tt> on
Windows).</dd>
<dt><tt class="docutils literal"><span class="pre">K</span></tt> (<a class="reference internal" href="../library/functions.html#int" title="int"><tt class="xref py py-class docutils literal"><span class="pre">int</span></tt></a>) [unsigned PY_LONG_LONG]</dt>
<dd>Convert a C <tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></tt> to a Python integer object. Only
available on platforms that support <tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></tt> (or
<tt class="xref c c-type docutils literal"><span class="pre">unsigned</span> <span class="pre">_int64</span></tt> on Windows).</dd>
<dt><tt class="docutils literal"><span class="pre">n</span></tt> (<a class="reference internal" href="../library/functions.html#int" title="int"><tt class="xref py py-class docutils literal"><span class="pre">int</span></tt></a>) [Py_ssize_t]</dt>
<dd>Convert a C <tt class="xref c c-type docutils literal"><span class="pre">Py_ssize_t</span></tt> to a Python integer.</dd>
<dt><tt class="docutils literal"><span class="pre">c</span></tt> (<a class="reference internal" href="../library/functions.html#bytes" title="bytes"><tt class="xref py py-class docutils literal"><span class="pre">bytes</span></tt></a> of length 1) [char]</dt>
<dd>Convert a C <tt class="xref c c-type docutils literal"><span class="pre">int</span></tt> representing a byte to a Python <a class="reference internal" href="../library/functions.html#bytes" title="bytes"><tt class="xref py py-class docutils literal"><span class="pre">bytes</span></tt></a> object of
length 1.</dd>
<dt><tt class="docutils literal"><span class="pre">C</span></tt> (<a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a> of length 1) [int]</dt>
<dd>Convert a C <tt class="xref c c-type docutils literal"><span class="pre">int</span></tt> representing a character to Python <a class="reference internal" href="../library/stdtypes.html#str" title="str"><tt class="xref py py-class docutils literal"><span class="pre">str</span></tt></a>
object of length 1.</dd>
<dt><tt class="docutils literal"><span class="pre">d</span></tt> (<a class="reference internal" href="../library/functions.html#float" title="float"><tt class="xref py py-class docutils literal"><span class="pre">float</span></tt></a>) [double]</dt>
<dd>Convert a C <tt class="xref c c-type docutils literal"><span class="pre">double</span></tt> to a Python floating point number.</dd>
<dt><tt class="docutils literal"><span class="pre">f</span></tt> (<a class="reference internal" href="../library/functions.html#float" title="float"><tt class="xref py py-class docutils literal"><span class="pre">float</span></tt></a>) [float]</dt>
<dd>Convert a C <tt class="xref c c-type docutils literal"><span class="pre">float</span></tt> to a Python floating point number.</dd>
<dt><tt class="docutils literal"><span class="pre">D</span></tt> (<a class="reference internal" href="../library/functions.html#complex" title="complex"><tt class="xref py py-class docutils literal"><span class="pre">complex</span></tt></a>) [Py_complex *]</dt>
<dd>Convert a C <a class="reference internal" href="complex.html#c.Py_complex" title="Py_complex"><tt class="xref c c-type docutils literal"><span class="pre">Py_complex</span></tt></a> structure to a Python complex number.</dd>
<dt><tt class="docutils literal"><span class="pre">O</span></tt> (object) [PyObject *]</dt>
<dd>Pass a Python object untouched (except for its reference count, which is
incremented by one).  If the object passed in is a <em>NULL</em> pointer, it is assumed
that this was caused because the call producing the argument found an error and
set an exception. Therefore, <a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><tt class="xref c c-func docutils literal"><span class="pre">Py_BuildValue()</span></tt></a> will return <em>NULL</em> but won&#8217;t
raise an exception.  If no exception has been raised yet, <a class="reference internal" href="../library/exceptions.html#SystemError" title="SystemError"><tt class="xref py py-exc docutils literal"><span class="pre">SystemError</span></tt></a> is
set.</dd>
<dt><tt class="docutils literal"><span class="pre">S</span></tt> (object) [PyObject *]</dt>
<dd>Same as <tt class="docutils literal"><span class="pre">O</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">N</span></tt> (object) [PyObject *]</dt>
<dd>Same as <tt class="docutils literal"><span class="pre">O</span></tt>, except it doesn&#8217;t increment the reference count on the object.
Useful when the object is created by a call to an object constructor in the
argument list.</dd>
<dt><tt class="docutils literal"><span class="pre">O&amp;</span></tt> (object) [<em>converter</em>, <em>anything</em>]</dt>
<dd>Convert <em>anything</em> to a Python object through a <em>converter</em> function.  The
function is called with <em>anything</em> (which should be compatible with <tt class="xref c c-type docutils literal"><span class="pre">void</span>
<span class="pre">*</span></tt>) as its argument and should return a &#8220;new&#8221; Python object, or <em>NULL</em> if an
error occurred.</dd>
<dt><tt class="docutils literal"><span class="pre">(items)</span></tt> (<a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><tt class="xref py py-class docutils literal"><span class="pre">tuple</span></tt></a>) [<em>matching-items</em>]</dt>
<dd>Convert a sequence of C values to a Python tuple with the same number of items.</dd>
<dt><tt class="docutils literal"><span class="pre">[items]</span></tt> (<a class="reference internal" href="../library/stdtypes.html#list" title="list"><tt class="xref py py-class docutils literal"><span class="pre">list</span></tt></a>) [<em>matching-items</em>]</dt>
<dd>Convert a sequence of C values to a Python list with the same number of items.</dd>
<dt><tt class="docutils literal"><span class="pre">{items}</span></tt> (<a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><tt class="xref py py-class docutils literal"><span class="pre">dict</span></tt></a>) [<em>matching-items</em>]</dt>
<dd>Convert a sequence of C values to a Python dictionary.  Each pair of consecutive
C values adds one item to the dictionary, serving as key and value,
respectively.</dd>
</dl>
<p>If there is an error in the format string, the <a class="reference internal" href="../library/exceptions.html#SystemError" title="SystemError"><tt class="xref py py-exc docutils literal"><span class="pre">SystemError</span></tt></a> exception is
set and <em>NULL</em> returned.</p>
</dd></dl>

<dl class="function">
<dt id="c.Py_VaBuildValue">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a>* <tt class="descname">Py_VaBuildValue</tt><big>(</big>const char<em>&nbsp;*format</em>, va_list<em>&nbsp;vargs</em><big>)</big><a class="headerlink" href="#c.Py_VaBuildValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Identical to <a class="reference internal" href="#c.Py_BuildValue" title="Py_BuildValue"><tt class="xref c c-func docutils literal"><span class="pre">Py_BuildValue()</span></tt></a>, except that it accepts a va_list
rather than a variable number of arguments.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Parsing arguments and building values</a><ul>
<li><a class="reference internal" href="#parsing-arguments">Parsing arguments</a><ul>
<li><a class="reference internal" href="#strings-and-buffers">Strings and buffers</a></li>
<li><a class="reference internal" href="#numbers">Numbers</a></li>
<li><a class="reference internal" href="#other-objects">Other objects</a></li>
<li><a class="reference internal" href="#api-functions">API Functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#building-values">Building values</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="marshal.html"
                        title="previous chapter">Data marshalling support</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="conversion.html"
                        title="next chapter">String conversion and formatting</a></p>
<h3>This Page</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">Report a Bug</a></li>
  <li><a href="../_sources/c-api/arg.txt"
         rel="nofollow">Show Source</a></li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="conversion.html" title="String conversion and formatting"
             >next</a> |</li>
        <li class="right" >
          <a href="marshal.html" title="Data marshalling support"
             >previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &raquo;</li>
        <li>
          <span class="version_switcher_placeholder">3.4.3</span>
          <a href="../index.html">Documentation</a> &raquo;
        </li>

          <li><a href="index.html" >Python/C API Reference Manual</a> &raquo;</li>
          <li><a href="utilities.html" >Utilities</a> &raquo;</li> 
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2015, Python Software Foundation.
    <br />
    The Python Software Foundation is a non-profit corporation.
    <a href="https://www.python.org/psf/donations/">Please donate.</a>
    <br />
    Last updated on Feb 26, 2015.
    <a href="../bugs.html">Found a bug</a>?
    <br />
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.3.
    </div>

  </body>
</html>