<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>18.5.1. Base Event Loop &mdash; Python 3.4.3 documentation</title>
    
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.4.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Python 3.4.3 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python 3.4.3 documentation" href="../index.html" />
    <link rel="up" title="18.5. asyncio – Asynchronous I/O, event loop, coroutines and tasks" href="asyncio.html" />
    <link rel="next" title="18.5.2. Event loops" href="asyncio-eventloops.html" />
    <link rel="prev" title="18.5. asyncio – Asynchronous I/O, event loop, coroutines and tasks" href="asyncio.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
 

  </head>
  <body>  
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="asyncio-eventloops.html" title="18.5.2. Event loops"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="asyncio.html" title="18.5. asyncio – Asynchronous I/O, event loop, coroutines and tasks"
             accesskey="P">previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &raquo;</li>
        <li>
          <span class="version_switcher_placeholder">3.4.3</span>
          <a href="../index.html">Documentation</a> &raquo;
        </li>

          <li><a href="index.html" >The Python Standard Library</a> &raquo;</li>
          <li><a href="ipc.html" >18. Interprocess Communication and Networking</a> &raquo;</li>
          <li><a href="asyncio.html" accesskey="U">18.5. <tt class="docutils literal"><span class="pre">asyncio</span></tt> &#8211; Asynchronous I/O, event loop, coroutines and tasks</a> &raquo;</li> 
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="base-event-loop">
<span id="asyncio-event-loop"></span><h1>18.5.1. Base Event Loop<a class="headerlink" href="#base-event-loop" title="Permalink to this headline">¶</a></h1>
<p>The event loop is the central execution device provided by <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O, event loop, coroutines and tasks."><tt class="xref py py-mod docutils literal"><span class="pre">asyncio</span></tt></a>.
It provides multiple facilities, amongst which:</p>
<ul class="simple">
<li>Registering, executing and cancelling delayed calls (timeouts).</li>
<li>Creating client and server <a class="reference internal" href="asyncio-protocol.html#asyncio-transport"><em>transports</em></a> for various
kinds of communication.</li>
<li>Launching subprocesses and the associated <a class="reference internal" href="asyncio-protocol.html#asyncio-transport"><em>transports</em></a> for communication with an external program.</li>
<li>Delegating costly function calls to a pool of threads.</li>
</ul>
<dl class="class">
<dt id="asyncio.BaseEventLoop">
<em class="property">class </em><tt class="descclassname">asyncio.</tt><tt class="descname">BaseEventLoop</tt><a class="headerlink" href="#asyncio.BaseEventLoop" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class of event loops.</p>
<p>This class is <a class="reference internal" href="asyncio-dev.html#asyncio-multithreading"><em>not thread safe</em></a>.</p>
</dd></dl>

<div class="section" id="run-an-event-loop">
<h2>18.5.1.1. Run an event loop<a class="headerlink" href="#run-an-event-loop" title="Permalink to this headline">¶</a></h2>
<dl class="method">
<dt id="asyncio.BaseEventLoop.run_forever">
<tt class="descclassname">BaseEventLoop.</tt><tt class="descname">run_forever</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.run_forever" title="Permalink to this definition">¶</a></dt>
<dd><p>Run until <a class="reference internal" href="#asyncio.BaseEventLoop.stop" title="asyncio.BaseEventLoop.stop"><tt class="xref py py-meth docutils literal"><span class="pre">stop()</span></tt></a> is called.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseEventLoop.run_until_complete">
<tt class="descclassname">BaseEventLoop.</tt><tt class="descname">run_until_complete</tt><big>(</big><em>future</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.run_until_complete" title="Permalink to this definition">¶</a></dt>
<dd><p>Run until the <a class="reference internal" href="asyncio-task.html#asyncio.Future" title="asyncio.Future"><tt class="xref py py-class docutils literal"><span class="pre">Future</span></tt></a> is done.</p>
<p>If the argument is a <a class="reference internal" href="asyncio-task.html#coroutine"><em>coroutine object</em></a>, it is wrapped by
<a class="reference internal" href="asyncio-task.html#asyncio.async" title="asyncio.async"><tt class="xref py py-func docutils literal"><span class="pre">async()</span></tt></a>.</p>
<p>Return the Future&#8217;s result, or raise its exception.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseEventLoop.is_running">
<tt class="descclassname">BaseEventLoop.</tt><tt class="descname">is_running</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.is_running" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns running status of event loop.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseEventLoop.stop">
<tt class="descclassname">BaseEventLoop.</tt><tt class="descname">stop</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop running the event loop.</p>
<p>Every callback scheduled before <a class="reference internal" href="#asyncio.BaseEventLoop.stop" title="asyncio.BaseEventLoop.stop"><tt class="xref py py-meth docutils literal"><span class="pre">stop()</span></tt></a> is called will run.
Callbacks scheduled after <a class="reference internal" href="#asyncio.BaseEventLoop.stop" title="asyncio.BaseEventLoop.stop"><tt class="xref py py-meth docutils literal"><span class="pre">stop()</span></tt></a> is called will not run.
However, those callbacks will run if <a class="reference internal" href="#asyncio.BaseEventLoop.run_forever" title="asyncio.BaseEventLoop.run_forever"><tt class="xref py py-meth docutils literal"><span class="pre">run_forever()</span></tt></a> is called
again later.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseEventLoop.is_closed">
<tt class="descclassname">BaseEventLoop.</tt><tt class="descname">is_closed</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.is_closed" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">True</span></tt> if the event loop was closed.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.4.2.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseEventLoop.close">
<tt class="descclassname">BaseEventLoop.</tt><tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the event loop. The loop must not be running.</p>
<p>This clears the queues and shuts down the executor, but does not wait for
the executor to finish.</p>
<p>This is idempotent and irreversible. No other methods should be called after
this one.</p>
</dd></dl>

</div>
<div class="section" id="calls">
<span id="asyncio-pass-keywords"></span><h2>18.5.1.2. Calls<a class="headerlink" href="#calls" title="Permalink to this headline">¶</a></h2>
<p>Most <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O, event loop, coroutines and tasks."><tt class="xref py py-mod docutils literal"><span class="pre">asyncio</span></tt></a> functions don&#8217;t accept keywords. If you want to pass
keywords to your callback, use <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><tt class="xref py py-func docutils literal"><span class="pre">functools.partial()</span></tt></a>. For example,
<tt class="docutils literal"><span class="pre">loop.call_soon(functools.partial(print,</span> <span class="pre">&quot;Hello&quot;,</span> <span class="pre">flush=True))</span></tt> will call
<tt class="docutils literal"><span class="pre">print(&quot;Hello&quot;,</span> <span class="pre">flush=True)</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><tt class="xref py py-func docutils literal"><span class="pre">functools.partial()</span></tt></a> is better than <tt class="docutils literal"><span class="pre">lambda</span></tt> functions, because
<a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O, event loop, coroutines and tasks."><tt class="xref py py-mod docutils literal"><span class="pre">asyncio</span></tt></a> can inspect <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><tt class="xref py py-func docutils literal"><span class="pre">functools.partial()</span></tt></a> object to display
parameters in debug mode, whereas <tt class="docutils literal"><span class="pre">lambda</span></tt> functions have a poor
representation.</p>
</div>
<dl class="method">
<dt id="asyncio.BaseEventLoop.call_soon">
<tt class="descclassname">BaseEventLoop.</tt><tt class="descname">call_soon</tt><big>(</big><em>callback</em>, <em>*args</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.call_soon" title="Permalink to this definition">¶</a></dt>
<dd><p>Arrange for a callback to be called as soon as possible.  The callback is
called after <a class="reference internal" href="#asyncio.BaseEventLoop.call_soon" title="asyncio.BaseEventLoop.call_soon"><tt class="xref py py-meth docutils literal"><span class="pre">call_soon()</span></tt></a> returns, when control returns to the event
loop.</p>
<p>This operates as a FIFO queue, callbacks are called in the order in
which they are registered.  Each callback will be called exactly once.</p>
<p>Any positional arguments after the callback will be passed to the
callback when it is called.</p>
<p>An instance of <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><tt class="xref py py-class docutils literal"><span class="pre">asyncio.Handle</span></tt></a> is returned, which can be
used to cancel the callback.</p>
<p><a class="reference internal" href="#asyncio-pass-keywords"><em>Use functools.partial to pass keywords to the callback</em></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseEventLoop.call_soon_threadsafe">
<tt class="descclassname">BaseEventLoop.</tt><tt class="descname">call_soon_threadsafe</tt><big>(</big><em>callback</em>, <em>*args</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.call_soon_threadsafe" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#asyncio.BaseEventLoop.call_soon" title="asyncio.BaseEventLoop.call_soon"><tt class="xref py py-meth docutils literal"><span class="pre">call_soon()</span></tt></a>, but thread safe.</p>
<p>See the <a class="reference internal" href="asyncio-dev.html#asyncio-multithreading"><em>concurrency and multithreading</em></a>
section of the documentation.</p>
</dd></dl>

</div>
<div class="section" id="delayed-calls">
<span id="asyncio-delayed-calls"></span><h2>18.5.1.3. Delayed calls<a class="headerlink" href="#delayed-calls" title="Permalink to this headline">¶</a></h2>
<p>The event loop has its own internal clock for computing timeouts.
Which clock is used depends on the (platform-specific) event loop
implementation; ideally it is a monotonic clock.  This will generally be
a different clock than <a class="reference internal" href="time.html#time.time" title="time.time"><tt class="xref py py-func docutils literal"><span class="pre">time.time()</span></tt></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Timeouts (relative <em>delay</em> or absolute <em>when</em>) should not exceed one day.</p>
</div>
<dl class="method">
<dt id="asyncio.BaseEventLoop.call_later">
<tt class="descclassname">BaseEventLoop.</tt><tt class="descname">call_later</tt><big>(</big><em>delay</em>, <em>callback</em>, <em>*args</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.call_later" title="Permalink to this definition">¶</a></dt>
<dd><p>Arrange for the <em>callback</em> to be called after the given <em>delay</em>
seconds (either an int or float).</p>
<p>An instance of <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><tt class="xref py py-class docutils literal"><span class="pre">asyncio.Handle</span></tt></a> is returned, which can be
used to cancel the callback.</p>
<p><em>callback</em> will be called exactly once per call to <a class="reference internal" href="#asyncio.BaseEventLoop.call_later" title="asyncio.BaseEventLoop.call_later"><tt class="xref py py-meth docutils literal"><span class="pre">call_later()</span></tt></a>.
If two callbacks are scheduled for exactly the same time, it is
undefined which will be called first.</p>
<p>The optional positional <em>args</em> will be passed to the callback when it
is called. If you want the callback to be called with some named
arguments, use a closure or <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><tt class="xref py py-func docutils literal"><span class="pre">functools.partial()</span></tt></a>.</p>
<p><a class="reference internal" href="#asyncio-pass-keywords"><em>Use functools.partial to pass keywords to the callback</em></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseEventLoop.call_at">
<tt class="descclassname">BaseEventLoop.</tt><tt class="descname">call_at</tt><big>(</big><em>when</em>, <em>callback</em>, <em>*args</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.call_at" title="Permalink to this definition">¶</a></dt>
<dd><p>Arrange for the <em>callback</em> to be called at the given absolute timestamp
<em>when</em> (an int or float), using the same time reference as
<a class="reference internal" href="#asyncio.BaseEventLoop.time" title="asyncio.BaseEventLoop.time"><tt class="xref py py-meth docutils literal"><span class="pre">BaseEventLoop.time()</span></tt></a>.</p>
<p>This method&#8217;s behavior is the same as <a class="reference internal" href="#asyncio.BaseEventLoop.call_later" title="asyncio.BaseEventLoop.call_later"><tt class="xref py py-meth docutils literal"><span class="pre">call_later()</span></tt></a>.</p>
<p>An instance of <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><tt class="xref py py-class docutils literal"><span class="pre">asyncio.Handle</span></tt></a> is returned, which can be
used to cancel the callback.</p>
<p><a class="reference internal" href="#asyncio-pass-keywords"><em>Use functools.partial to pass keywords to the callback</em></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseEventLoop.time">
<tt class="descclassname">BaseEventLoop.</tt><tt class="descname">time</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.time" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current time, as a <a class="reference internal" href="functions.html#float" title="float"><tt class="xref py py-class docutils literal"><span class="pre">float</span></tt></a> value, according to the
event loop&#8217;s internal clock.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="asyncio-task.html#asyncio.sleep" title="asyncio.sleep"><tt class="xref py py-func docutils literal"><span class="pre">asyncio.sleep()</span></tt></a> function.</p>
</div>
</div>
<div class="section" id="tasks">
<h2>18.5.1.4. Tasks<a class="headerlink" href="#tasks" title="Permalink to this headline">¶</a></h2>
<dl class="method">
<dt id="asyncio.BaseEventLoop.create_task">
<tt class="descclassname">BaseEventLoop.</tt><tt class="descname">create_task</tt><big>(</big><em>coro</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.create_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Schedule the execution of a <a class="reference internal" href="asyncio-task.html#coroutine"><em>coroutine object</em></a>: wrap it in
a future. Return a <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><tt class="xref py py-class docutils literal"><span class="pre">Task</span></tt></a> object.</p>
<p>Third-party event loops can use their own subclass of <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><tt class="xref py py-class docutils literal"><span class="pre">Task</span></tt></a> for
interoperability. In this case, the result type is a subclass of
<a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><tt class="xref py py-class docutils literal"><span class="pre">Task</span></tt></a>.</p>
<p>This method was added in Python 3.4.2. Use the <a class="reference internal" href="asyncio-task.html#asyncio.async" title="asyncio.async"><tt class="xref py py-func docutils literal"><span class="pre">async()</span></tt></a> function to
support also older Python versions.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.4.2.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseEventLoop.set_task_factory">
<tt class="descclassname">BaseEventLoop.</tt><tt class="descname">set_task_factory</tt><big>(</big><em>factory</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.set_task_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a task factory that will be used by
<a class="reference internal" href="#asyncio.BaseEventLoop.create_task" title="asyncio.BaseEventLoop.create_task"><tt class="xref py py-meth docutils literal"><span class="pre">BaseEventLoop.create_task()</span></tt></a>.</p>
<p>If <em>factory</em> is <tt class="docutils literal"><span class="pre">None</span></tt> the default task factory will be set.</p>
<p>If <em>factory</em> is a <em>callable</em>, it should have a signature matching
<tt class="docutils literal"><span class="pre">(loop,</span> <span class="pre">coro)</span></tt>, where <em>loop</em> will be a reference to the active
event loop, <em>coro</em> will be a coroutine object.  The callable
must return an <a class="reference internal" href="asyncio-task.html#asyncio.Future" title="asyncio.Future"><tt class="xref py py-class docutils literal"><span class="pre">asyncio.Future</span></tt></a> compatible object.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.4.4.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseEventLoop.get_task_factory">
<tt class="descclassname">BaseEventLoop.</tt><tt class="descname">get_task_factory</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.get_task_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a task factory, or <tt class="docutils literal"><span class="pre">None</span></tt> if the default one is in use.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.4.4.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="creating-connections">
<h2>18.5.1.5. Creating connections<a class="headerlink" href="#creating-connections" title="Permalink to this headline">¶</a></h2>
<dl class="method">
<dt id="asyncio.BaseEventLoop.create_connection">
<em class="property">coroutine </em><tt class="descclassname">BaseEventLoop.</tt><tt class="descname">create_connection</tt><big>(</big><em>protocol_factory</em>, <em>host=None</em>, <em>port=None</em>, <em>*</em>, <em>ssl=None</em>, <em>family=0</em>, <em>proto=0</em>, <em>flags=0</em>, <em>sock=None</em>, <em>local_addr=None</em>, <em>server_hostname=None</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.create_connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a streaming transport connection to a given Internet <em>host</em> and
<em>port</em>: socket family <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><tt class="xref py py-data docutils literal"><span class="pre">AF_INET</span></tt></a> or
<a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><tt class="xref py py-data docutils literal"><span class="pre">AF_INET6</span></tt></a> depending on <em>host</em> (or <em>family</em> if specified),
socket type <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><tt class="xref py py-data docutils literal"><span class="pre">SOCK_STREAM</span></tt></a>.  <em>protocol_factory</em> must be a
callable returning a <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><em>protocol</em></a> instance.</p>
<p>This method is a <a class="reference internal" href="asyncio-task.html#coroutine"><em>coroutine</em></a> which will try to
establish the connection in the background.  When successful, the
coroutine returns a <tt class="docutils literal"><span class="pre">(transport,</span> <span class="pre">protocol)</span></tt> pair.</p>
<p>The chronological synopsis of the underlying operation is as follows:</p>
<ol class="arabic simple">
<li>The connection is established, and a <a class="reference internal" href="asyncio-protocol.html#asyncio-transport"><em>transport</em></a>
is created to represent it.</li>
<li><em>protocol_factory</em> is called without arguments and must return a
<a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><em>protocol</em></a> instance.</li>
<li>The protocol instance is tied to the transport, and its
<tt class="xref py py-meth docutils literal"><span class="pre">connection_made()</span></tt> method is called.</li>
<li>The coroutine returns successfully with the <tt class="docutils literal"><span class="pre">(transport,</span> <span class="pre">protocol)</span></tt>
pair.</li>
</ol>
<p>The created transport is an implementation-dependent bidirectional stream.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><em>protocol_factory</em> can be any kind of callable, not necessarily
a class.  For example, if you want to use a pre-created
protocol instance, you can pass <tt class="docutils literal"><span class="pre">lambda:</span> <span class="pre">my_protocol</span></tt>.</p>
</div>
<p>Options allowing to change how the connection is created:</p>
<ul>
<li><p class="first"><em>ssl</em>: if given and not false, a SSL/TLS transport is created
(by default a plain TCP transport is created).  If <em>ssl</em> is
a <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><tt class="xref py py-class docutils literal"><span class="pre">ssl.SSLContext</span></tt></a> object, this context is used to create
the transport; if <em>ssl</em> is <a class="reference internal" href="constants.html#True" title="True"><tt class="xref py py-const docutils literal"><span class="pre">True</span></tt></a>, a context with some
unspecified default settings is used.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="ssl.html#ssl-security"><em>SSL/TLS security considerations</em></a></p>
</div>
</li>
<li><p class="first"><em>server_hostname</em>, is only for use together with <em>ssl</em>,
and sets or overrides the hostname that the target server&#8217;s certificate
will be matched against.  By default the value of the <em>host</em> argument
is used.  If <em>host</em> is empty, there is no default and you must pass a
value for <em>server_hostname</em>.  If <em>server_hostname</em> is an empty
string, hostname matching is disabled (which is a serious security
risk, allowing for man-in-the-middle-attacks).</p>
</li>
<li><p class="first"><em>family</em>, <em>proto</em>, <em>flags</em> are the optional address family, protocol
and flags to be passed through to getaddrinfo() for <em>host</em> resolution.
If given, these should all be integers from the corresponding
<a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><tt class="xref py py-mod docutils literal"><span class="pre">socket</span></tt></a> module constants.</p>
</li>
<li><p class="first"><em>sock</em>, if given, should be an existing, already connected
<a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><tt class="xref py py-class docutils literal"><span class="pre">socket.socket</span></tt></a> object to be used by the transport.
If <em>sock</em> is given, none of <em>host</em>, <em>port</em>, <em>family</em>, <em>proto</em>, <em>flags</em>
and <em>local_addr</em> should be specified.</p>
</li>
<li><p class="first"><em>local_addr</em>, if given, is a <tt class="docutils literal"><span class="pre">(local_host,</span> <span class="pre">local_port)</span></tt> tuple used
to bind the socket to locally.  The <em>local_host</em> and <em>local_port</em>
are looked up using getaddrinfo(), similarly to <em>host</em> and <em>port</em>.</p>
</li>
</ul>
<p>On Windows with <a class="reference internal" href="asyncio-eventloops.html#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><tt class="xref py py-class docutils literal"><span class="pre">ProactorEventLoop</span></tt></a>, SSL/TLS is not supported.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><tt class="xref py py-func docutils literal"><span class="pre">open_connection()</span></tt></a> function can be used to get a pair of
(<a class="reference internal" href="asyncio-stream.html#asyncio.StreamReader" title="asyncio.StreamReader"><tt class="xref py py-class docutils literal"><span class="pre">StreamReader</span></tt></a>, <a class="reference internal" href="asyncio-stream.html#asyncio.StreamWriter" title="asyncio.StreamWriter"><tt class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></tt></a>) instead of a protocol.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseEventLoop.create_datagram_endpoint">
<em class="property">coroutine </em><tt class="descclassname">BaseEventLoop.</tt><tt class="descname">create_datagram_endpoint</tt><big>(</big><em>protocol_factory</em>, <em>local_addr=None</em>, <em>remote_addr=None</em>, <em>*</em>, <em>family=0</em>, <em>proto=0</em>, <em>flags=0</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.create_datagram_endpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Create datagram connection: socket family <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><tt class="xref py py-data docutils literal"><span class="pre">AF_INET</span></tt></a> or
<a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><tt class="xref py py-data docutils literal"><span class="pre">AF_INET6</span></tt></a> depending on <em>host</em> (or <em>family</em> if specified),
socket type <a class="reference internal" href="socket.html#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><tt class="xref py py-data docutils literal"><span class="pre">SOCK_DGRAM</span></tt></a>.</p>
<p>This method is a <a class="reference internal" href="asyncio-task.html#coroutine"><em>coroutine</em></a> which will try to
establish the connection in the background.  When successful, the
coroutine returns a <tt class="docutils literal"><span class="pre">(transport,</span> <span class="pre">protocol)</span></tt> pair.</p>
<p>See the <a class="reference internal" href="#asyncio.BaseEventLoop.create_connection" title="asyncio.BaseEventLoop.create_connection"><tt class="xref py py-meth docutils literal"><span class="pre">BaseEventLoop.create_connection()</span></tt></a> method for parameters.</p>
<p>On Windows with <a class="reference internal" href="asyncio-eventloops.html#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><tt class="xref py py-class docutils literal"><span class="pre">ProactorEventLoop</span></tt></a>, this method is not supported.</p>
<p>See <a class="reference internal" href="asyncio-protocol.html#asyncio-udp-echo-client-protocol"><em>UDP echo client protocol</em></a> and
<a class="reference internal" href="asyncio-protocol.html#asyncio-udp-echo-server-protocol"><em>UDP echo server protocol</em></a> examples.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseEventLoop.create_unix_connection">
<em class="property">coroutine </em><tt class="descclassname">BaseEventLoop.</tt><tt class="descname">create_unix_connection</tt><big>(</big><em>protocol_factory</em>, <em>path</em>, <em>*</em>, <em>ssl=None</em>, <em>sock=None</em>, <em>server_hostname=None</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.create_unix_connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Create UNIX connection: socket family <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><tt class="xref py py-data docutils literal"><span class="pre">AF_UNIX</span></tt></a>, socket
type <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><tt class="xref py py-data docutils literal"><span class="pre">SOCK_STREAM</span></tt></a>. The <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><tt class="xref py py-data docutils literal"><span class="pre">AF_UNIX</span></tt></a> socket
family is used to communicate between processes on the same machine
efficiently.</p>
<p>This method is a <a class="reference internal" href="asyncio-task.html#coroutine"><em>coroutine</em></a> which will try to
establish the connection in the background.  When successful, the
coroutine returns a <tt class="docutils literal"><span class="pre">(transport,</span> <span class="pre">protocol)</span></tt> pair.</p>
<p>See the <a class="reference internal" href="#asyncio.BaseEventLoop.create_connection" title="asyncio.BaseEventLoop.create_connection"><tt class="xref py py-meth docutils literal"><span class="pre">BaseEventLoop.create_connection()</span></tt></a> method for parameters.</p>
<p>Availability: UNIX.</p>
</dd></dl>

</div>
<div class="section" id="creating-listening-connections">
<h2>18.5.1.6. Creating listening connections<a class="headerlink" href="#creating-listening-connections" title="Permalink to this headline">¶</a></h2>
<dl class="method">
<dt id="asyncio.BaseEventLoop.create_server">
<em class="property">coroutine </em><tt class="descclassname">BaseEventLoop.</tt><tt class="descname">create_server</tt><big>(</big><em>protocol_factory</em>, <em>host=None</em>, <em>port=None</em>, <em>*</em>, <em>family=socket.AF_UNSPEC</em>, <em>flags=socket.AI_PASSIVE</em>, <em>sock=None</em>, <em>backlog=100</em>, <em>ssl=None</em>, <em>reuse_address=None</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.create_server" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a TCP server (socket type <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><tt class="xref py py-data docutils literal"><span class="pre">SOCK_STREAM</span></tt></a>) bound to
<em>host</em> and <em>port</em>.</p>
<p>Return a <a class="reference internal" href="#asyncio.Server" title="asyncio.Server"><tt class="xref py py-class docutils literal"><span class="pre">Server</span></tt></a> object, its <a class="reference internal" href="#asyncio.Server.sockets" title="asyncio.Server.sockets"><tt class="xref py py-attr docutils literal"><span class="pre">sockets</span></tt></a> attribute
contains created sockets. Use the <a class="reference internal" href="#asyncio.Server.close" title="asyncio.Server.close"><tt class="xref py py-meth docutils literal"><span class="pre">Server.close()</span></tt></a> method to stop the
server: close listening sockets.</p>
<p>Parameters:</p>
<ul class="simple">
<li>If <em>host</em> is an empty string or <tt class="docutils literal"><span class="pre">None</span></tt>, all interfaces are assumed
and a list of multiple sockets will be returned (most likely
one for IPv4 and another one for IPv6).</li>
<li><em>family</em> can be set to either <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><tt class="xref py py-data docutils literal"><span class="pre">socket.AF_INET</span></tt></a> or
<a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><tt class="xref py py-data docutils literal"><span class="pre">AF_INET6</span></tt></a> to force the socket to use IPv4 or IPv6. If not set
it will be determined from host (defaults to <tt class="xref py py-data docutils literal"><span class="pre">socket.AF_UNSPEC</span></tt>).</li>
<li><em>flags</em> is a bitmask for <a class="reference internal" href="#asyncio.BaseEventLoop.getaddrinfo" title="asyncio.BaseEventLoop.getaddrinfo"><tt class="xref py py-meth docutils literal"><span class="pre">getaddrinfo()</span></tt></a>.</li>
<li><em>sock</em> can optionally be specified in order to use a preexisting
socket object. If specified, <em>host</em> and <em>port</em> should be omitted (must be
<a class="reference internal" href="constants.html#None" title="None"><tt class="xref py py-const docutils literal"><span class="pre">None</span></tt></a>).</li>
<li><em>backlog</em> is the maximum number of queued connections passed to
<a class="reference internal" href="socket.html#socket.socket.listen" title="socket.socket.listen"><tt class="xref py py-meth docutils literal"><span class="pre">listen()</span></tt></a> (defaults to 100).</li>
<li><em>ssl</em> can be set to an <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><tt class="xref py py-class docutils literal"><span class="pre">SSLContext</span></tt></a> to enable SSL over the
accepted connections.</li>
<li><em>reuse_address</em> tells the kernel to reuse a local socket in
TIME_WAIT state, without waiting for its natural timeout to
expire. If not specified will automatically be set to True on
UNIX.</li>
</ul>
<p>This method is a <a class="reference internal" href="asyncio-task.html#coroutine"><em>coroutine</em></a>.</p>
<p>On Windows with <a class="reference internal" href="asyncio-eventloops.html#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><tt class="xref py py-class docutils literal"><span class="pre">ProactorEventLoop</span></tt></a>, SSL/TLS is not supported.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The function <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><tt class="xref py py-func docutils literal"><span class="pre">start_server()</span></tt></a> creates a (<a class="reference internal" href="asyncio-stream.html#asyncio.StreamReader" title="asyncio.StreamReader"><tt class="xref py py-class docutils literal"><span class="pre">StreamReader</span></tt></a>,
<a class="reference internal" href="asyncio-stream.html#asyncio.StreamWriter" title="asyncio.StreamWriter"><tt class="xref py py-class docutils literal"><span class="pre">StreamWriter</span></tt></a>) pair and calls back a function with this pair.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseEventLoop.create_unix_server">
<em class="property">coroutine </em><tt class="descclassname">BaseEventLoop.</tt><tt class="descname">create_unix_server</tt><big>(</big><em>protocol_factory</em>, <em>path=None</em>, <em>*</em>, <em>sock=None</em>, <em>backlog=100</em>, <em>ssl=None</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.create_unix_server" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to <a class="reference internal" href="#asyncio.BaseEventLoop.create_server" title="asyncio.BaseEventLoop.create_server"><tt class="xref py py-meth docutils literal"><span class="pre">BaseEventLoop.create_server()</span></tt></a>, but specific to the
socket family <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><tt class="xref py py-data docutils literal"><span class="pre">AF_UNIX</span></tt></a>.</p>
<p>This method is a <a class="reference internal" href="asyncio-task.html#coroutine"><em>coroutine</em></a>.</p>
<p>Availability: UNIX.</p>
</dd></dl>

</div>
<div class="section" id="watch-file-descriptors">
<h2>18.5.1.7. Watch file descriptors<a class="headerlink" href="#watch-file-descriptors" title="Permalink to this headline">¶</a></h2>
<p>On Windows with <a class="reference internal" href="asyncio-eventloops.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><tt class="xref py py-class docutils literal"><span class="pre">SelectorEventLoop</span></tt></a>, only socket handles are supported
(ex: pipe file descriptors are not supported).</p>
<p>On Windows with <a class="reference internal" href="asyncio-eventloops.html#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><tt class="xref py py-class docutils literal"><span class="pre">ProactorEventLoop</span></tt></a>, these methods are not supported.</p>
<dl class="method">
<dt id="asyncio.BaseEventLoop.add_reader">
<tt class="descclassname">BaseEventLoop.</tt><tt class="descname">add_reader</tt><big>(</big><em>fd</em>, <em>callback</em>, <em>*args</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.add_reader" title="Permalink to this definition">¶</a></dt>
<dd><p>Start watching the file descriptor for read availability and then call the
<em>callback</em> with specified arguments.</p>
<p><a class="reference internal" href="#asyncio-pass-keywords"><em>Use functools.partial to pass keywords to the callback</em></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseEventLoop.remove_reader">
<tt class="descclassname">BaseEventLoop.</tt><tt class="descname">remove_reader</tt><big>(</big><em>fd</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.remove_reader" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop watching the file descriptor for read availability.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseEventLoop.add_writer">
<tt class="descclassname">BaseEventLoop.</tt><tt class="descname">add_writer</tt><big>(</big><em>fd</em>, <em>callback</em>, <em>*args</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.add_writer" title="Permalink to this definition">¶</a></dt>
<dd><p>Start watching the file descriptor for write availability and then call the
<em>callback</em> with specified arguments.</p>
<p><a class="reference internal" href="#asyncio-pass-keywords"><em>Use functools.partial to pass keywords to the callback</em></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseEventLoop.remove_writer">
<tt class="descclassname">BaseEventLoop.</tt><tt class="descname">remove_writer</tt><big>(</big><em>fd</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.remove_writer" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop watching the file descriptor for write availability.</p>
</dd></dl>

<p>The <a class="reference internal" href="#asyncio-watch-read-event"><em>watch a file descriptor for read events</em></a>
example uses the low-level <a class="reference internal" href="#asyncio.BaseEventLoop.add_reader" title="asyncio.BaseEventLoop.add_reader"><tt class="xref py py-meth docutils literal"><span class="pre">BaseEventLoop.add_reader()</span></tt></a> method to register
the file descriptor of a socket.</p>
</div>
<div class="section" id="low-level-socket-operations">
<h2>18.5.1.8. Low-level socket operations<a class="headerlink" href="#low-level-socket-operations" title="Permalink to this headline">¶</a></h2>
<dl class="method">
<dt id="asyncio.BaseEventLoop.sock_recv">
<em class="property">coroutine </em><tt class="descclassname">BaseEventLoop.</tt><tt class="descname">sock_recv</tt><big>(</big><em>sock</em>, <em>nbytes</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.sock_recv" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive data from the socket.  The return value is a bytes object
representing the data received.  The maximum amount of data to be received
at once is specified by <em>nbytes</em>.</p>
<p>With <a class="reference internal" href="asyncio-eventloops.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><tt class="xref py py-class docutils literal"><span class="pre">SelectorEventLoop</span></tt></a> event loop, the socket <em>sock</em> must be
non-blocking.</p>
<p>This method is a <a class="reference internal" href="asyncio-task.html#coroutine"><em>coroutine</em></a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="socket.html#socket.socket.recv" title="socket.socket.recv"><tt class="xref py py-meth docutils literal"><span class="pre">socket.socket.recv()</span></tt></a> method.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseEventLoop.sock_sendall">
<em class="property">coroutine </em><tt class="descclassname">BaseEventLoop.</tt><tt class="descname">sock_sendall</tt><big>(</big><em>sock</em>, <em>data</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.sock_sendall" title="Permalink to this definition">¶</a></dt>
<dd><p>Send data to the socket.  The socket must be connected to a remote socket.
This method continues to send data from <em>data</em> until either all data has
been sent or an error occurs.  <tt class="docutils literal"><span class="pre">None</span></tt> is returned on success.  On error,
an exception is raised, and there is no way to determine how much data, if
any, was successfully processed by the receiving end of the connection.</p>
<p>With <a class="reference internal" href="asyncio-eventloops.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><tt class="xref py py-class docutils literal"><span class="pre">SelectorEventLoop</span></tt></a> event loop, the socket <em>sock</em> must be
non-blocking.</p>
<p>This method is a <a class="reference internal" href="asyncio-task.html#coroutine"><em>coroutine</em></a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="socket.html#socket.socket.sendall" title="socket.socket.sendall"><tt class="xref py py-meth docutils literal"><span class="pre">socket.socket.sendall()</span></tt></a> method.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseEventLoop.sock_connect">
<em class="property">coroutine </em><tt class="descclassname">BaseEventLoop.</tt><tt class="descname">sock_connect</tt><big>(</big><em>sock</em>, <em>address</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.sock_connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect to a remote socket at <em>address</em>.</p>
<p>The <em>address</em> must be already resolved to avoid the trap of hanging the
entire event loop when the address requires doing a DNS lookup.  For
example, it must be an IP address, not an hostname, for
<a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><tt class="xref py py-data docutils literal"><span class="pre">AF_INET</span></tt></a> and <a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><tt class="xref py py-data docutils literal"><span class="pre">AF_INET6</span></tt></a> address families.
Use <a class="reference internal" href="#asyncio.BaseEventLoop.getaddrinfo" title="asyncio.BaseEventLoop.getaddrinfo"><tt class="xref py py-meth docutils literal"><span class="pre">getaddrinfo()</span></tt></a> to resolve the hostname asynchronously.</p>
<p>With <a class="reference internal" href="asyncio-eventloops.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><tt class="xref py py-class docutils literal"><span class="pre">SelectorEventLoop</span></tt></a> event loop, the socket <em>sock</em> must be
non-blocking.</p>
<p>This method is a <a class="reference internal" href="asyncio-task.html#coroutine"><em>coroutine</em></a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="#asyncio.BaseEventLoop.create_connection" title="asyncio.BaseEventLoop.create_connection"><tt class="xref py py-meth docutils literal"><span class="pre">BaseEventLoop.create_connection()</span></tt></a> method, the
<a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><tt class="xref py py-func docutils literal"><span class="pre">open_connection()</span></tt></a> function and the <a class="reference internal" href="socket.html#socket.socket.connect" title="socket.socket.connect"><tt class="xref py py-meth docutils literal"><span class="pre">socket.socket.connect()</span></tt></a>
method.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseEventLoop.sock_accept">
<em class="property">coroutine </em><tt class="descclassname">BaseEventLoop.</tt><tt class="descname">sock_accept</tt><big>(</big><em>sock</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.sock_accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Accept a connection. The socket must be bound to an address and listening
for connections. The return value is a pair <tt class="docutils literal"><span class="pre">(conn,</span> <span class="pre">address)</span></tt> where <em>conn</em>
is a <em>new</em> socket object usable to send and receive data on the connection,
and <em>address</em> is the address bound to the socket on the other end of the
connection.</p>
<p>The socket <em>sock</em> must be non-blocking.</p>
<p>This method is a <a class="reference internal" href="asyncio-task.html#coroutine"><em>coroutine</em></a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="#asyncio.BaseEventLoop.create_server" title="asyncio.BaseEventLoop.create_server"><tt class="xref py py-meth docutils literal"><span class="pre">BaseEventLoop.create_server()</span></tt></a> method, the <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><tt class="xref py py-func docutils literal"><span class="pre">start_server()</span></tt></a>
function and the <a class="reference internal" href="socket.html#socket.socket.accept" title="socket.socket.accept"><tt class="xref py py-meth docutils literal"><span class="pre">socket.socket.accept()</span></tt></a> method.</p>
</div>
</dd></dl>

</div>
<div class="section" id="resolve-host-name">
<h2>18.5.1.9. Resolve host name<a class="headerlink" href="#resolve-host-name" title="Permalink to this headline">¶</a></h2>
<dl class="method">
<dt id="asyncio.BaseEventLoop.getaddrinfo">
<em class="property">coroutine </em><tt class="descclassname">BaseEventLoop.</tt><tt class="descname">getaddrinfo</tt><big>(</big><em>host</em>, <em>port</em>, <em>*</em>, <em>family=0</em>, <em>type=0</em>, <em>proto=0</em>, <em>flags=0</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.getaddrinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is a <a class="reference internal" href="asyncio-task.html#coroutine"><em>coroutine</em></a>, similar to
<a class="reference internal" href="socket.html#socket.getaddrinfo" title="socket.getaddrinfo"><tt class="xref py py-meth docutils literal"><span class="pre">socket.getaddrinfo()</span></tt></a> function but non-blocking.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseEventLoop.getnameinfo">
<em class="property">coroutine </em><tt class="descclassname">BaseEventLoop.</tt><tt class="descname">getnameinfo</tt><big>(</big><em>sockaddr</em>, <em>flags=0</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.getnameinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is a <a class="reference internal" href="asyncio-task.html#coroutine"><em>coroutine</em></a>, similar to
<a class="reference internal" href="socket.html#socket.getnameinfo" title="socket.getnameinfo"><tt class="xref py py-meth docutils literal"><span class="pre">socket.getnameinfo()</span></tt></a> function but non-blocking.</p>
</dd></dl>

</div>
<div class="section" id="connect-pipes">
<h2>18.5.1.10. Connect pipes<a class="headerlink" href="#connect-pipes" title="Permalink to this headline">¶</a></h2>
<p>On Windows with <a class="reference internal" href="asyncio-eventloops.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><tt class="xref py py-class docutils literal"><span class="pre">SelectorEventLoop</span></tt></a>, these methods are not supported.
Use <a class="reference internal" href="asyncio-eventloops.html#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><tt class="xref py py-class docutils literal"><span class="pre">ProactorEventLoop</span></tt></a> to support pipes on Windows.</p>
<dl class="method">
<dt id="asyncio.BaseEventLoop.connect_read_pipe">
<em class="property">coroutine </em><tt class="descclassname">BaseEventLoop.</tt><tt class="descname">connect_read_pipe</tt><big>(</big><em>protocol_factory</em>, <em>pipe</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.connect_read_pipe" title="Permalink to this definition">¶</a></dt>
<dd><p>Register read pipe in eventloop.</p>
<p><em>protocol_factory</em> should instantiate object with <a class="reference internal" href="asyncio-protocol.html#asyncio.Protocol" title="asyncio.Protocol"><tt class="xref py py-class docutils literal"><span class="pre">Protocol</span></tt></a>
interface.  <em>pipe</em> is a <a class="reference internal" href="../glossary.html#term-file-object"><em class="xref std std-term">file-like object</em></a>.
Return pair <tt class="docutils literal"><span class="pre">(transport,</span> <span class="pre">protocol)</span></tt>, where <em>transport</em> supports the
<a class="reference internal" href="asyncio-protocol.html#asyncio.ReadTransport" title="asyncio.ReadTransport"><tt class="xref py py-class docutils literal"><span class="pre">ReadTransport</span></tt></a> interface.</p>
<p>With <a class="reference internal" href="asyncio-eventloops.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><tt class="xref py py-class docutils literal"><span class="pre">SelectorEventLoop</span></tt></a> event loop, the <em>pipe</em> is set to
non-blocking mode.</p>
<p>This method is a <a class="reference internal" href="asyncio-task.html#coroutine"><em>coroutine</em></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseEventLoop.connect_write_pipe">
<em class="property">coroutine </em><tt class="descclassname">BaseEventLoop.</tt><tt class="descname">connect_write_pipe</tt><big>(</big><em>protocol_factory</em>, <em>pipe</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.connect_write_pipe" title="Permalink to this definition">¶</a></dt>
<dd><p>Register write pipe in eventloop.</p>
<p><em>protocol_factory</em> should instantiate object with <tt class="xref py py-class docutils literal"><span class="pre">BaseProtocol</span></tt>
interface. <em>pipe</em> is <a class="reference internal" href="../glossary.html#term-file-object"><em class="xref std std-term">file-like object</em></a>.
Return pair <tt class="docutils literal"><span class="pre">(transport,</span> <span class="pre">protocol)</span></tt>, where <em>transport</em> supports
<a class="reference internal" href="asyncio-protocol.html#asyncio.WriteTransport" title="asyncio.WriteTransport"><tt class="xref py py-class docutils literal"><span class="pre">WriteTransport</span></tt></a> interface.</p>
<p>With <a class="reference internal" href="asyncio-eventloops.html#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><tt class="xref py py-class docutils literal"><span class="pre">SelectorEventLoop</span></tt></a> event loop, the <em>pipe</em> is set to
non-blocking mode.</p>
<p>This method is a <a class="reference internal" href="asyncio-task.html#coroutine"><em>coroutine</em></a>.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="asyncio-subprocess.html#asyncio.BaseEventLoop.subprocess_exec" title="asyncio.BaseEventLoop.subprocess_exec"><tt class="xref py py-meth docutils literal"><span class="pre">BaseEventLoop.subprocess_exec()</span></tt></a> and
<a class="reference internal" href="asyncio-subprocess.html#asyncio.BaseEventLoop.subprocess_shell" title="asyncio.BaseEventLoop.subprocess_shell"><tt class="xref py py-meth docutils literal"><span class="pre">BaseEventLoop.subprocess_shell()</span></tt></a> methods.</p>
</div>
</div>
<div class="section" id="unix-signals">
<h2>18.5.1.11. UNIX signals<a class="headerlink" href="#unix-signals" title="Permalink to this headline">¶</a></h2>
<p>Availability: UNIX only.</p>
<dl class="method">
<dt id="asyncio.BaseEventLoop.add_signal_handler">
<tt class="descclassname">BaseEventLoop.</tt><tt class="descname">add_signal_handler</tt><big>(</big><em>signum</em>, <em>callback</em>, <em>*args</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.add_signal_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a handler for a signal.</p>
<p>Raise <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> if the signal number is invalid or uncatchable.
Raise <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a> if there is a problem setting up the handler.</p>
<p><a class="reference internal" href="#asyncio-pass-keywords"><em>Use functools.partial to pass keywords to the callback</em></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseEventLoop.remove_signal_handler">
<tt class="descclassname">BaseEventLoop.</tt><tt class="descname">remove_signal_handler</tt><big>(</big><em>sig</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.remove_signal_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a handler for a signal.</p>
<p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if a signal handler was removed, <tt class="docutils literal"><span class="pre">False</span></tt> if not.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="signal.html#module-signal" title="signal: Set handlers for asynchronous events."><tt class="xref py py-mod docutils literal"><span class="pre">signal</span></tt></a> module.</p>
</div>
</div>
<div class="section" id="executor">
<h2>18.5.1.12. Executor<a class="headerlink" href="#executor" title="Permalink to this headline">¶</a></h2>
<p>Call a function in an <a class="reference internal" href="concurrent.futures.html#concurrent.futures.Executor" title="concurrent.futures.Executor"><tt class="xref py py-class docutils literal"><span class="pre">Executor</span></tt></a> (pool of threads or
pool of processes). By default, an event loop uses a thread pool executor
(<a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><tt class="xref py py-class docutils literal"><span class="pre">ThreadPoolExecutor</span></tt></a>).</p>
<dl class="method">
<dt id="asyncio.BaseEventLoop.run_in_executor">
<em class="property">coroutine </em><tt class="descclassname">BaseEventLoop.</tt><tt class="descname">run_in_executor</tt><big>(</big><em>executor</em>, <em>callback</em>, <em>*args</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.run_in_executor" title="Permalink to this definition">¶</a></dt>
<dd><p>Arrange for a callback to be called in the specified executor.</p>
<p>The <em>executor</em> argument should be an <a class="reference internal" href="concurrent.futures.html#concurrent.futures.Executor" title="concurrent.futures.Executor"><tt class="xref py py-class docutils literal"><span class="pre">Executor</span></tt></a>
instance. The default executor is used if <em>executor</em> is <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
<p><a class="reference internal" href="#asyncio-pass-keywords"><em>Use functools.partial to pass keywords to the callback</em></a>.</p>
<p>This method is a <a class="reference internal" href="asyncio-task.html#coroutine"><em>coroutine</em></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseEventLoop.set_default_executor">
<tt class="descclassname">BaseEventLoop.</tt><tt class="descname">set_default_executor</tt><big>(</big><em>executor</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.set_default_executor" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the default executor used by <a class="reference internal" href="#asyncio.BaseEventLoop.run_in_executor" title="asyncio.BaseEventLoop.run_in_executor"><tt class="xref py py-meth docutils literal"><span class="pre">run_in_executor()</span></tt></a>.</p>
</dd></dl>

</div>
<div class="section" id="error-handling-api">
<h2>18.5.1.13. Error Handling API<a class="headerlink" href="#error-handling-api" title="Permalink to this headline">¶</a></h2>
<p>Allows to customize how exceptions are handled in the event loop.</p>
<dl class="method">
<dt id="asyncio.BaseEventLoop.set_exception_handler">
<tt class="descclassname">BaseEventLoop.</tt><tt class="descname">set_exception_handler</tt><big>(</big><em>handler</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.set_exception_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>Set <em>handler</em> as the new event loop exception handler.</p>
<p>If <em>handler</em> is <tt class="docutils literal"><span class="pre">None</span></tt>, the default exception handler will
be set.</p>
<p>If <em>handler</em> is a callable object, it should have a
matching signature to <tt class="docutils literal"><span class="pre">(loop,</span> <span class="pre">context)</span></tt>, where <tt class="docutils literal"><span class="pre">loop</span></tt>
will be a reference to the active event loop, <tt class="docutils literal"><span class="pre">context</span></tt>
will be a <tt class="docutils literal"><span class="pre">dict</span></tt> object (see <a class="reference internal" href="#asyncio.BaseEventLoop.call_exception_handler" title="asyncio.BaseEventLoop.call_exception_handler"><tt class="xref py py-meth docutils literal"><span class="pre">call_exception_handler()</span></tt></a>
documentation for details about context).</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseEventLoop.default_exception_handler">
<tt class="descclassname">BaseEventLoop.</tt><tt class="descname">default_exception_handler</tt><big>(</big><em>context</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.default_exception_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>Default exception handler.</p>
<p>This is called when an exception occurs and no exception
handler is set, and can be called by a custom exception
handler that wants to defer to the default behavior.</p>
<p><em>context</em> parameter has the same meaning as in
<a class="reference internal" href="#asyncio.BaseEventLoop.call_exception_handler" title="asyncio.BaseEventLoop.call_exception_handler"><tt class="xref py py-meth docutils literal"><span class="pre">call_exception_handler()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseEventLoop.call_exception_handler">
<tt class="descclassname">BaseEventLoop.</tt><tt class="descname">call_exception_handler</tt><big>(</big><em>context</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.call_exception_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the current event loop exception handler.</p>
<p><em>context</em> is a <tt class="docutils literal"><span class="pre">dict</span></tt> object containing the following keys
(new keys may be introduced later):</p>
<ul class="simple">
<li>&#8216;message&#8217;: Error message;</li>
<li>&#8216;exception&#8217; (optional): Exception object;</li>
<li>&#8216;future&#8217; (optional): <a class="reference internal" href="asyncio-task.html#asyncio.Future" title="asyncio.Future"><tt class="xref py py-class docutils literal"><span class="pre">asyncio.Future</span></tt></a> instance;</li>
<li>&#8216;handle&#8217; (optional): <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><tt class="xref py py-class docutils literal"><span class="pre">asyncio.Handle</span></tt></a> instance;</li>
<li>&#8216;protocol&#8217; (optional): <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><em>Protocol</em></a> instance;</li>
<li>&#8216;transport&#8217; (optional): <a class="reference internal" href="asyncio-protocol.html#asyncio-transport"><em>Transport</em></a> instance;</li>
<li>&#8216;socket&#8217; (optional): <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><tt class="xref py py-class docutils literal"><span class="pre">socket.socket</span></tt></a> instance.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Note: this method should not be overloaded in subclassed
event loops.  For any custom exception handling, use
<a class="reference internal" href="#asyncio.BaseEventLoop.set_exception_handler" title="asyncio.BaseEventLoop.set_exception_handler"><tt class="xref py py-meth docutils literal"><span class="pre">set_exception_handler()</span></tt></a> method.</p>
</div>
</dd></dl>

</div>
<div class="section" id="debug-mode">
<h2>18.5.1.14. Debug mode<a class="headerlink" href="#debug-mode" title="Permalink to this headline">¶</a></h2>
<dl class="method">
<dt id="asyncio.BaseEventLoop.get_debug">
<tt class="descclassname">BaseEventLoop.</tt><tt class="descname">get_debug</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.get_debug" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the debug mode (<a class="reference internal" href="functions.html#bool" title="bool"><tt class="xref py py-class docutils literal"><span class="pre">bool</span></tt></a>) of the event loop.</p>
<p>The default value is <tt class="docutils literal"><span class="pre">True</span></tt> if the environment variable
<span class="target" id="index-0"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONASYNCIODEBUG"><tt class="xref std std-envvar docutils literal"><span class="pre">PYTHONASYNCIODEBUG</span></tt></a> is set to a non-empty string, <tt class="docutils literal"><span class="pre">False</span></tt>
otherwise.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.4.2.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.BaseEventLoop.set_debug">
<tt class="descclassname">BaseEventLoop.</tt><tt class="descname">set_debug</tt><big>(</big><em>enabled: bool</em><big>)</big><a class="headerlink" href="#asyncio.BaseEventLoop.set_debug" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the debug mode of the event loop.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.4.2.</span></p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="asyncio-dev.html#asyncio-debug-mode"><em>debug mode of asyncio</em></a>.</p>
</div>
</div>
<div class="section" id="server">
<h2>18.5.1.15. Server<a class="headerlink" href="#server" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="asyncio.Server">
<em class="property">class </em><tt class="descclassname">asyncio.</tt><tt class="descname">Server</tt><a class="headerlink" href="#asyncio.Server" title="Permalink to this definition">¶</a></dt>
<dd><p>Server listening on sockets.</p>
<p>Object created by the <a class="reference internal" href="#asyncio.BaseEventLoop.create_server" title="asyncio.BaseEventLoop.create_server"><tt class="xref py py-meth docutils literal"><span class="pre">BaseEventLoop.create_server()</span></tt></a> method and the
<a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><tt class="xref py py-func docutils literal"><span class="pre">start_server()</span></tt></a> function. Don&#8217;t instantiate the class directly.</p>
<dl class="method">
<dt id="asyncio.Server.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.Server.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop serving: close listening sockets and set the <a class="reference internal" href="#asyncio.Server.sockets" title="asyncio.Server.sockets"><tt class="xref py py-attr docutils literal"><span class="pre">sockets</span></tt></a>
attribute to <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
<p>The sockets that represent existing incoming client connections are
leaved open.</p>
<p>The server is closed asynchonously, use the <a class="reference internal" href="#asyncio.Server.wait_closed" title="asyncio.Server.wait_closed"><tt class="xref py py-meth docutils literal"><span class="pre">wait_closed()</span></tt></a> coroutine
to wait until the server is closed.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Server.wait_closed">
<em class="property">coroutine </em><tt class="descname">wait_closed</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.Server.wait_closed" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait until the <a class="reference internal" href="#asyncio.Server.close" title="asyncio.Server.close"><tt class="xref py py-meth docutils literal"><span class="pre">close()</span></tt></a> method completes.</p>
<p>This method is a <a class="reference internal" href="asyncio-task.html#coroutine"><em>coroutine</em></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="asyncio.Server.sockets">
<tt class="descname">sockets</tt><a class="headerlink" href="#asyncio.Server.sockets" title="Permalink to this definition">¶</a></dt>
<dd><p>List of <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><tt class="xref py py-class docutils literal"><span class="pre">socket.socket</span></tt></a> objects the server is listening to, or
<tt class="docutils literal"><span class="pre">None</span></tt> if the server is closed.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="handle">
<h2>18.5.1.16. Handle<a class="headerlink" href="#handle" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="asyncio.Handle">
<em class="property">class </em><tt class="descclassname">asyncio.</tt><tt class="descname">Handle</tt><a class="headerlink" href="#asyncio.Handle" title="Permalink to this definition">¶</a></dt>
<dd><p>A callback wrapper object returned by <a class="reference internal" href="#asyncio.BaseEventLoop.call_soon" title="asyncio.BaseEventLoop.call_soon"><tt class="xref py py-func docutils literal"><span class="pre">BaseEventLoop.call_soon()</span></tt></a>,
<a class="reference internal" href="#asyncio.BaseEventLoop.call_soon_threadsafe" title="asyncio.BaseEventLoop.call_soon_threadsafe"><tt class="xref py py-func docutils literal"><span class="pre">BaseEventLoop.call_soon_threadsafe()</span></tt></a>, <a class="reference internal" href="#asyncio.BaseEventLoop.call_later" title="asyncio.BaseEventLoop.call_later"><tt class="xref py py-func docutils literal"><span class="pre">BaseEventLoop.call_later()</span></tt></a>,
and <a class="reference internal" href="#asyncio.BaseEventLoop.call_at" title="asyncio.BaseEventLoop.call_at"><tt class="xref py py-func docutils literal"><span class="pre">BaseEventLoop.call_at()</span></tt></a>.</p>
<dl class="method">
<dt id="asyncio.Handle.cancel">
<tt class="descname">cancel</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.Handle.cancel" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancel the call.  If the callback is already canceled or executed,
this method has no effect.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="event-loop-examples">
<h2>18.5.1.17. Event loop examples<a class="headerlink" href="#event-loop-examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="hello-world-with-call-soon">
<span id="asyncio-hello-world-callback"></span><h3>18.5.1.17.1. Hello World with call_soon()<a class="headerlink" href="#hello-world-with-call-soon" title="Permalink to this headline">¶</a></h3>
<p>Example using the <a class="reference internal" href="#asyncio.BaseEventLoop.call_soon" title="asyncio.BaseEventLoop.call_soon"><tt class="xref py py-meth docutils literal"><span class="pre">BaseEventLoop.call_soon()</span></tt></a> method to schedule a
callback. The callback displays <tt class="docutils literal"><span class="pre">&quot;Hello</span> <span class="pre">World&quot;</span></tt> and then stops the event
loop:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="k">def</span> <span class="nf">hello_world</span><span class="p">(</span><span class="n">loop</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">&#39;Hello World&#39;</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

<span class="c"># Schedule a call to hello_world()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">hello_world</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>

<span class="c"># Blocking call interrupted by loop.stop()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="asyncio-task.html#asyncio-hello-world-coroutine"><em>Hello World coroutine</em></a> example
uses a <a class="reference internal" href="asyncio-task.html#coroutine"><em>coroutine</em></a>.</p>
</div>
</div>
<div class="section" id="display-the-current-date-with-call-later">
<span id="asyncio-date-callback"></span><h3>18.5.1.17.2. Display the current date with call_later()<a class="headerlink" href="#display-the-current-date-with-call-later" title="Permalink to this headline">¶</a></h3>
<p>Example of callback displaying the current date every second. The callback uses
the <a class="reference internal" href="#asyncio.BaseEventLoop.call_later" title="asyncio.BaseEventLoop.call_later"><tt class="xref py py-meth docutils literal"><span class="pre">BaseEventLoop.call_later()</span></tt></a> method to reschedule itself during 5
seconds, and then stops the event loop:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">datetime</span>

<span class="k">def</span> <span class="nf">display_date</span><span class="p">(</span><span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">end_time</span><span class="p">:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">call_later</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">display_date</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

<span class="c"># Schedule the first call to display_date()</span>
<span class="n">end_time</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">5.0</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">display_date</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>

<span class="c"># Blocking call interrupted by loop.stop()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="asyncio-task.html#asyncio-date-coroutine"><em>coroutine displaying the current date</em></a> example uses a <a class="reference internal" href="asyncio-task.html#coroutine"><em>coroutine</em></a>.</p>
</div>
</div>
<div class="section" id="watch-a-file-descriptor-for-read-events">
<span id="asyncio-watch-read-event"></span><h3>18.5.1.17.3. Watch a file descriptor for read events<a class="headerlink" href="#watch-a-file-descriptor-for-read-events" title="Permalink to this headline">¶</a></h3>
<p>Wait until a file descriptor received some data using the
<a class="reference internal" href="#asyncio.BaseEventLoop.add_reader" title="asyncio.BaseEventLoop.add_reader"><tt class="xref py py-meth docutils literal"><span class="pre">BaseEventLoop.add_reader()</span></tt></a> method and then close the event loop:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">socket</span> <span class="k">import</span> <span class="n">socketpair</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">asyncio.windows_utils</span> <span class="k">import</span> <span class="n">socketpair</span>

<span class="c"># Create a pair of connected file descriptors</span>
<span class="n">rsock</span><span class="p">,</span> <span class="n">wsock</span> <span class="o">=</span> <span class="n">socketpair</span><span class="p">()</span>
<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">reader</span><span class="p">():</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">rsock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">&quot;Received:&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span>
    <span class="c"># We are done: unregister the file descriptor</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">remove_reader</span><span class="p">(</span><span class="n">rsock</span><span class="p">)</span>
    <span class="c"># Stop the event loop</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="c"># Register the file descriptor for read event</span>
<span class="n">loop</span><span class="o">.</span><span class="n">add_reader</span><span class="p">(</span><span class="n">rsock</span><span class="p">,</span> <span class="n">reader</span><span class="p">)</span>

<span class="c"># Simulate the reception of data from the network</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">wsock</span><span class="o">.</span><span class="n">send</span><span class="p">,</span> <span class="s">&#39;abc&#39;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="c"># Run the event loop</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>

<span class="c"># We are done, close sockets and the event loop</span>
<span class="n">rsock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">wsock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p>The <a class="reference internal" href="asyncio-protocol.html#asyncio-register-socket"><em>register an open socket to wait for data using a protocol</em></a> example uses a low-level protocol created by the
<a class="reference internal" href="#asyncio.BaseEventLoop.create_connection" title="asyncio.BaseEventLoop.create_connection"><tt class="xref py py-meth docutils literal"><span class="pre">BaseEventLoop.create_connection()</span></tt></a> method.</p>
<p class="last">The <a class="reference internal" href="asyncio-stream.html#asyncio-register-socket-streams"><em>register an open socket to wait for data using streams</em></a> example uses high-level streams
created by the <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><tt class="xref py py-func docutils literal"><span class="pre">open_connection()</span></tt></a> function in a coroutine.</p>
</div>
</div>
<div class="section" id="set-signal-handlers-for-sigint-and-sigterm">
<h3>18.5.1.17.4. Set signal handlers for SIGINT and SIGTERM<a class="headerlink" href="#set-signal-handlers-for-sigint-and-sigterm" title="Permalink to this headline">¶</a></h3>
<p>Register handlers for signals <tt class="xref py py-data docutils literal"><span class="pre">SIGINT</span></tt> and <tt class="xref py py-data docutils literal"><span class="pre">SIGTERM</span></tt> using
the <a class="reference internal" href="#asyncio.BaseEventLoop.add_signal_handler" title="asyncio.BaseEventLoop.add_signal_handler"><tt class="xref py py-meth docutils literal"><span class="pre">BaseEventLoop.add_signal_handler()</span></tt></a> method:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">signal</span>

<span class="k">def</span> <span class="nf">ask_exit</span><span class="p">(</span><span class="n">signame</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">&quot;got signal %s: exit&quot;</span> <span class="o">%</span> <span class="n">signame</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="k">for</span> <span class="n">signame</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;SIGINT&#39;</span><span class="p">,</span> <span class="s">&#39;SIGTERM&#39;</span><span class="p">):</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">add_signal_handler</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">signame</span><span class="p">),</span>
                            <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">ask_exit</span><span class="p">,</span> <span class="n">signame</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="s">&quot;Event loop running forever, press CTRL+c to interrupt.&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s">&quot;pid %s: send SIGINT or SIGTERM to exit.&quot;</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>This example only works on UNIX.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">18.5.1. Base Event Loop</a><ul>
<li><a class="reference internal" href="#run-an-event-loop">18.5.1.1. Run an event loop</a></li>
<li><a class="reference internal" href="#calls">18.5.1.2. Calls</a></li>
<li><a class="reference internal" href="#delayed-calls">18.5.1.3. Delayed calls</a></li>
<li><a class="reference internal" href="#tasks">18.5.1.4. Tasks</a></li>
<li><a class="reference internal" href="#creating-connections">18.5.1.5. Creating connections</a></li>
<li><a class="reference internal" href="#creating-listening-connections">18.5.1.6. Creating listening connections</a></li>
<li><a class="reference internal" href="#watch-file-descriptors">18.5.1.7. Watch file descriptors</a></li>
<li><a class="reference internal" href="#low-level-socket-operations">18.5.1.8. Low-level socket operations</a></li>
<li><a class="reference internal" href="#resolve-host-name">18.5.1.9. Resolve host name</a></li>
<li><a class="reference internal" href="#connect-pipes">18.5.1.10. Connect pipes</a></li>
<li><a class="reference internal" href="#unix-signals">18.5.1.11. UNIX signals</a></li>
<li><a class="reference internal" href="#executor">18.5.1.12. Executor</a></li>
<li><a class="reference internal" href="#error-handling-api">18.5.1.13. Error Handling API</a></li>
<li><a class="reference internal" href="#debug-mode">18.5.1.14. Debug mode</a></li>
<li><a class="reference internal" href="#server">18.5.1.15. Server</a></li>
<li><a class="reference internal" href="#handle">18.5.1.16. Handle</a></li>
<li><a class="reference internal" href="#event-loop-examples">18.5.1.17. Event loop examples</a><ul>
<li><a class="reference internal" href="#hello-world-with-call-soon">18.5.1.17.1. Hello World with call_soon()</a></li>
<li><a class="reference internal" href="#display-the-current-date-with-call-later">18.5.1.17.2. Display the current date with call_later()</a></li>
<li><a class="reference internal" href="#watch-a-file-descriptor-for-read-events">18.5.1.17.3. Watch a file descriptor for read events</a></li>
<li><a class="reference internal" href="#set-signal-handlers-for-sigint-and-sigterm">18.5.1.17.4. Set signal handlers for SIGINT and SIGTERM</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="asyncio.html"
                        title="previous chapter">18.5. <tt class="docutils literal"><span class="pre">asyncio</span></tt> &#8211; Asynchronous I/O, event loop, coroutines and tasks</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="asyncio-eventloops.html"
                        title="next chapter">18.5.2. Event loops</a></p>
<h3>This Page</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">Report a Bug</a></li>
  <li><a href="../_sources/library/asyncio-eventloop.txt"
         rel="nofollow">Show Source</a></li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="asyncio-eventloops.html" title="18.5.2. Event loops"
             >next</a> |</li>
        <li class="right" >
          <a href="asyncio.html" title="18.5. asyncio – Asynchronous I/O, event loop, coroutines and tasks"
             >previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &raquo;</li>
        <li>
          <span class="version_switcher_placeholder">3.4.3</span>
          <a href="../index.html">Documentation</a> &raquo;
        </li>

          <li><a href="index.html" >The Python Standard Library</a> &raquo;</li>
          <li><a href="ipc.html" >18. Interprocess Communication and Networking</a> &raquo;</li>
          <li><a href="asyncio.html" >18.5. <tt class="docutils literal"><span class="pre">asyncio</span></tt> &#8211; Asynchronous I/O, event loop, coroutines and tasks</a> &raquo;</li> 
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2015, Python Software Foundation.
    <br />
    The Python Software Foundation is a non-profit corporation.
    <a href="https://www.python.org/psf/donations/">Please donate.</a>
    <br />
    Last updated on Jun 25, 2015.
    <a href="../bugs.html">Found a bug</a>?
    <br />
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.3.
    </div>

  </body>
</html>