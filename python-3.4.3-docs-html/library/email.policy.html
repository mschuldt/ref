<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>19.1.4. email.policy: Policy Objects &mdash; Python 3.4.3 documentation</title>
    
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.4.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Python 3.4.3 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python 3.4.3 documentation" href="../index.html" />
    <link rel="up" title="19.1. email — An email and MIME handling package" href="email.html" />
    <link rel="next" title="19.1.5. email.headerregistry: Custom Header Objects" href="email.headerregistry.html" />
    <link rel="prev" title="19.1.3. email.generator: Generating MIME documents" href="email.generator.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
 

  </head>
  <body>  
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="email.headerregistry.html" title="19.1.5. email.headerregistry: Custom Header Objects"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="email.generator.html" title="19.1.3. email.generator: Generating MIME documents"
             accesskey="P">previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &raquo;</li>
        <li>
          <span class="version_switcher_placeholder">3.4.3</span>
          <a href="../index.html">Documentation</a> &raquo;
        </li>

          <li><a href="index.html" >The Python Standard Library</a> &raquo;</li>
          <li><a href="netdata.html" >19. Internet Data Handling</a> &raquo;</li>
          <li><a href="email.html" accesskey="U">19.1. <tt class="docutils literal"><span class="pre">email</span></tt> &#8212; An email and MIME handling package</a> &raquo;</li> 
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-email.policy">
<span id="email-policy-policy-objects"></span><h1>19.1.4. <a class="reference internal" href="#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><tt class="xref py py-mod docutils literal"><span class="pre">email.policy</span></tt></a>: Policy Objects<a class="headerlink" href="#module-email.policy" title="Permalink to this headline">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.3.</span></p>
</div>
<p>The <a class="reference internal" href="email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages, including MIME documents."><tt class="xref py py-mod docutils literal"><span class="pre">email</span></tt></a> package&#8217;s prime focus is the handling of email messages as
described by the various email and MIME RFCs.  However, the general format of
email messages (a block of header fields each consisting of a name followed by
a colon followed by a value, the whole block followed by a blank line and an
arbitrary &#8216;body&#8217;), is a format that has found utility outside of the realm of
email.  Some of these uses conform fairly closely to the main RFCs, some do
not.  And even when working with email, there are times when it is desirable to
break strict compliance with the RFCs.</p>
<p>Policy objects give the email package the flexibility to handle all these
disparate use cases.</p>
<p>A <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><tt class="xref py py-class docutils literal"><span class="pre">Policy</span></tt></a> object encapsulates a set of attributes and methods that
control the behavior of various components of the email package during use.
<a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><tt class="xref py py-class docutils literal"><span class="pre">Policy</span></tt></a> instances can be passed to various classes and methods in the
email package to alter the default behavior.  The settable values and their
defaults are described below.</p>
<p>There is a default policy used by all classes in the email package.  This
policy is named <a class="reference internal" href="#email.policy.Compat32" title="email.policy.Compat32"><tt class="xref py py-class docutils literal"><span class="pre">Compat32</span></tt></a>, with a corresponding pre-defined instance
named <tt class="xref py py-const docutils literal"><span class="pre">compat32</span></tt>.  It provides for complete backward compatibility (in
some cases, including bug compatibility) with the pre-Python3.3 version of the
email package.</p>
<p>The first part of this documentation covers the features of <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><tt class="xref py py-class docutils literal"><span class="pre">Policy</span></tt></a>, an
<a class="reference internal" href="../glossary.html#term-abstract-base-class"><em class="xref std std-term">abstract base class</em></a>  that defines the features that are common to all
policy objects, including <tt class="xref py py-const docutils literal"><span class="pre">compat32</span></tt>.  This includes certain hook
methods that are called internally by the email package, which a custom policy
could override to obtain different behavior.</p>
<p>When a <a class="reference internal" href="email.message.html#email.message.Message" title="email.message.Message"><tt class="xref py py-class docutils literal"><span class="pre">Message</span></tt></a> object is created, it acquires a policy.
By default this will be <tt class="xref py py-const docutils literal"><span class="pre">compat32</span></tt>, but a different policy can be
specified.  If the <tt class="docutils literal"><span class="pre">Message</span></tt> is created by a <a class="reference internal" href="email.parser.html#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><tt class="xref py py-mod docutils literal"><span class="pre">parser</span></tt></a>, a policy
passed to the parser will be the policy used by the <tt class="docutils literal"><span class="pre">Message</span></tt> it creates.  If
the <tt class="docutils literal"><span class="pre">Message</span></tt> is created by the program, then the policy can be specified
when it is created.  When a <tt class="docutils literal"><span class="pre">Message</span></tt> is passed to a <a class="reference internal" href="email.generator.html#module-email.generator" title="email.generator: Generate flat text email messages from a message structure."><tt class="xref py py-mod docutils literal"><span class="pre">generator</span></tt></a>,
the generator uses the policy from the <tt class="docutils literal"><span class="pre">Message</span></tt> by default, but you can also
pass a specific policy to the generator that will override the one stored on
the <tt class="docutils literal"><span class="pre">Message</span></tt> object.</p>
<p><a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><tt class="xref py py-class docutils literal"><span class="pre">Policy</span></tt></a> instances are immutable, but they can be cloned, accepting the
same keyword arguments as the class constructor and returning a new
<a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><tt class="xref py py-class docutils literal"><span class="pre">Policy</span></tt></a> instance that is a copy of the original but with the specified
attributes values changed.</p>
<p>As an example, the following code could be used to read an email message from a
file on disk and pass it to the system <tt class="docutils literal"><span class="pre">sendmail</span></tt> program on a Unix system:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">email</span> <span class="k">import</span> <span class="n">message_from_binary_file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">email.generator</span> <span class="k">import</span> <span class="n">BytesGenerator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">email</span> <span class="k">import</span> <span class="n">policy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">subprocess</span> <span class="k">import</span> <span class="n">Popen</span><span class="p">,</span> <span class="n">PIPE</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;mymsg.txt&#39;</span><span class="p">,</span> <span class="s">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">msg</span> <span class="o">=</span> <span class="n">message_from_binary_file</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">policy</span><span class="o">=</span><span class="n">policy</span><span class="o">.</span><span class="n">default</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s">&#39;sendmail&#39;</span><span class="p">,</span> <span class="n">msg</span><span class="p">[</span><span class="s">&#39;To&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">addresses</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">stdin</span><span class="o">=</span><span class="n">PIPE</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">BytesGenerator</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">stdin</span><span class="p">,</span> <span class="n">policy</span><span class="o">=</span><span class="n">msg</span><span class="o">.</span><span class="n">policy</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">linesep</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\r\n</span><span class="s">&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
</pre></div>
</div>
<p>Here we are telling <a class="reference internal" href="email.generator.html#email.generator.BytesGenerator" title="email.generator.BytesGenerator"><tt class="xref py py-class docutils literal"><span class="pre">BytesGenerator</span></tt></a> to use the RFC
correct line separator characters when creating the binary string to feed into
<tt class="docutils literal"><span class="pre">sendmail's</span></tt> <tt class="docutils literal"><span class="pre">stdin</span></tt>, where the default policy would use <tt class="docutils literal"><span class="pre">\n</span></tt> line
separators.</p>
<p>Some email package methods accept a <em>policy</em> keyword argument, allowing the
policy to be overridden for that method.  For example, the following code uses
the <a class="reference internal" href="email.message.html#email.message.Message.as_bytes" title="email.message.Message.as_bytes"><tt class="xref py py-meth docutils literal"><span class="pre">as_bytes()</span></tt></a> method of the <em>msg</em> object from
the previous example and writes the message to a file using the native line
separators for the platform on which it is running:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;converted.txt&#39;</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">as_bytes</span><span class="p">(</span><span class="n">policy</span><span class="o">=</span><span class="n">msg</span><span class="o">.</span><span class="n">policy</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">linesep</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="p">)))</span>
<span class="go">17</span>
</pre></div>
</div>
<p>Policy objects can also be combined using the addition operator, producing a
policy object whose settings are a combination of the non-default values of the
summed objects:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">compat_SMTP</span> <span class="o">=</span> <span class="n">policy</span><span class="o">.</span><span class="n">compat32</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">linesep</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\r\n</span><span class="s">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compat_strict</span> <span class="o">=</span> <span class="n">policy</span><span class="o">.</span><span class="n">compat32</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">raise_on_defect</span><span class="o">=</span><span class="k">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compat_strict_SMTP</span> <span class="o">=</span> <span class="n">compat_SMTP</span> <span class="o">+</span> <span class="n">compat_strict</span>
</pre></div>
</div>
<p>This operation is not commutative; that is, the order in which the objects are
added matters.  To illustrate:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">policy100</span> <span class="o">=</span> <span class="n">policy</span><span class="o">.</span><span class="n">compat32</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">max_line_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">policy80</span> <span class="o">=</span> <span class="n">policy</span><span class="o">.</span><span class="n">compat32</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">max_line_length</span><span class="o">=</span><span class="mi">80</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apolicy</span> <span class="o">=</span> <span class="n">policy100</span> <span class="o">+</span> <span class="n">policy80</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apolicy</span><span class="o">.</span><span class="n">max_line_length</span>
<span class="go">80</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apolicy</span> <span class="o">=</span> <span class="n">policy80</span> <span class="o">+</span> <span class="n">policy100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apolicy</span><span class="o">.</span><span class="n">max_line_length</span>
<span class="go">100</span>
</pre></div>
</div>
<dl class="class">
<dt id="email.policy.Policy">
<em class="property">class </em><tt class="descclassname">email.policy.</tt><tt class="descname">Policy</tt><big>(</big><em>**kw</em><big>)</big><a class="headerlink" href="#email.policy.Policy" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the <a class="reference internal" href="../glossary.html#term-abstract-base-class"><em class="xref std std-term">abstract base class</em></a> for all policy classes.  It provides
default implementations for a couple of trivial methods, as well as the
implementation of the immutability property, the <a class="reference internal" href="#email.policy.Policy.clone" title="email.policy.Policy.clone"><tt class="xref py py-meth docutils literal"><span class="pre">clone()</span></tt></a> method, and
the constructor semantics.</p>
<p>The constructor of a policy class can be passed various keyword arguments.
The arguments that may be specified are any non-method properties on this
class, plus any additional non-method properties on the concrete class.  A
value specified in the constructor will override the default value for the
corresponding attribute.</p>
<p>This class defines the following properties, and thus values for the
following may be passed in the constructor of any policy class:</p>
<dl class="attribute">
<dt id="email.policy.Policy.max_line_length">
<tt class="descname">max_line_length</tt><a class="headerlink" href="#email.policy.Policy.max_line_length" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum length of any line in the serialized output, not counting the
end of line character(s).  Default is 78, per <span class="target" id="index-0"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>.  A value of
<tt class="docutils literal"><span class="pre">0</span></tt> or <a class="reference internal" href="constants.html#None" title="None"><tt class="xref py py-const docutils literal"><span class="pre">None</span></tt></a> indicates that no line wrapping should be
done at all.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.Policy.linesep">
<tt class="descname">linesep</tt><a class="headerlink" href="#email.policy.Policy.linesep" title="Permalink to this definition">¶</a></dt>
<dd><p>The string to be used to terminate lines in serialized output.  The
default is <tt class="docutils literal"><span class="pre">\n</span></tt> because that&#8217;s the internal end-of-line discipline used
by Python, though <tt class="docutils literal"><span class="pre">\r\n</span></tt> is required by the RFCs.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.Policy.cte_type">
<tt class="descname">cte_type</tt><a class="headerlink" href="#email.policy.Policy.cte_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls the type of Content Transfer Encodings that may be or are
required to be used.  The possible values are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="89%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">7bit</span></tt></td>
<td>all data must be &#8220;7 bit clean&#8221; (ASCII-only).  This means that
where necessary data will be encoded using either
quoted-printable or base64 encoding.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">8bit</span></tt></td>
<td>data is not constrained to be 7 bit clean.  Data in headers is
still required to be ASCII-only and so will be encoded (see
&#8216;binary_fold&#8217; below for an exception), but body parts may use
the <tt class="docutils literal"><span class="pre">8bit</span></tt> CTE.</td>
</tr>
</tbody>
</table>
<p>A <tt class="docutils literal"><span class="pre">cte_type</span></tt> value of <tt class="docutils literal"><span class="pre">8bit</span></tt> only works with <tt class="docutils literal"><span class="pre">BytesGenerator</span></tt>, not
<tt class="docutils literal"><span class="pre">Generator</span></tt>, because strings cannot contain binary data.  If a
<tt class="docutils literal"><span class="pre">Generator</span></tt> is operating under a policy that specifies
<tt class="docutils literal"><span class="pre">cte_type=8bit</span></tt>, it will act as if <tt class="docutils literal"><span class="pre">cte_type</span></tt> is <tt class="docutils literal"><span class="pre">7bit</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.Policy.raise_on_defect">
<tt class="descname">raise_on_defect</tt><a class="headerlink" href="#email.policy.Policy.raise_on_defect" title="Permalink to this definition">¶</a></dt>
<dd><p>If <a class="reference internal" href="constants.html#True" title="True"><tt class="xref py py-const docutils literal"><span class="pre">True</span></tt></a>, any defects encountered will be raised as errors.  If
<a class="reference internal" href="constants.html#False" title="False"><tt class="xref py py-const docutils literal"><span class="pre">False</span></tt></a> (the default), defects will be passed to the
<a class="reference internal" href="#email.policy.Policy.register_defect" title="email.policy.Policy.register_defect"><tt class="xref py py-meth docutils literal"><span class="pre">register_defect()</span></tt></a> method.</p>
</dd></dl>

<p>The following <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><tt class="xref py py-class docutils literal"><span class="pre">Policy</span></tt></a> method is intended to be called by code using
the email library to create policy instances with custom settings:</p>
<dl class="method">
<dt id="email.policy.Policy.clone">
<tt class="descname">clone</tt><big>(</big><em>**kw</em><big>)</big><a class="headerlink" href="#email.policy.Policy.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><tt class="xref py py-class docutils literal"><span class="pre">Policy</span></tt></a> instance whose attributes have the same
values as the current instance, except where those attributes are
given new values by the keyword arguments.</p>
</dd></dl>

<p>The remaining <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><tt class="xref py py-class docutils literal"><span class="pre">Policy</span></tt></a> methods are called by the email package code,
and are not intended to be called by an application using the email package.
A custom policy must implement all of these methods.</p>
<dl class="method">
<dt id="email.policy.Policy.handle_defect">
<tt class="descname">handle_defect</tt><big>(</big><em>obj</em>, <em>defect</em><big>)</big><a class="headerlink" href="#email.policy.Policy.handle_defect" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle a <em>defect</em> found on <em>obj</em>.  When the email package calls this
method, <em>defect</em> will always be a subclass of
<tt class="xref py py-class docutils literal"><span class="pre">Defect</span></tt>.</p>
<p>The default implementation checks the <a class="reference internal" href="#email.policy.Policy.raise_on_defect" title="email.policy.Policy.raise_on_defect"><tt class="xref py py-attr docutils literal"><span class="pre">raise_on_defect</span></tt></a> flag.  If
it is <tt class="docutils literal"><span class="pre">True</span></tt>, <em>defect</em> is raised as an exception.  If it is <tt class="docutils literal"><span class="pre">False</span></tt>
(the default), <em>obj</em> and <em>defect</em> are passed to <a class="reference internal" href="#email.policy.Policy.register_defect" title="email.policy.Policy.register_defect"><tt class="xref py py-meth docutils literal"><span class="pre">register_defect()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Policy.register_defect">
<tt class="descname">register_defect</tt><big>(</big><em>obj</em>, <em>defect</em><big>)</big><a class="headerlink" href="#email.policy.Policy.register_defect" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a <em>defect</em> on <em>obj</em>.  In the email package, <em>defect</em> will always
be a subclass of <tt class="xref py py-class docutils literal"><span class="pre">Defect</span></tt>.</p>
<p>The default implementation calls the <tt class="docutils literal"><span class="pre">append</span></tt> method of the <tt class="docutils literal"><span class="pre">defects</span></tt>
attribute of <em>obj</em>.  When the email package calls <a class="reference internal" href="#email.policy.Policy.handle_defect" title="email.policy.Policy.handle_defect"><tt class="xref py py-attr docutils literal"><span class="pre">handle_defect</span></tt></a>,
<em>obj</em> will normally have a <tt class="docutils literal"><span class="pre">defects</span></tt> attribute that has an <tt class="docutils literal"><span class="pre">append</span></tt>
method.  Custom object types used with the email package (for example,
custom <tt class="docutils literal"><span class="pre">Message</span></tt> objects) should also provide such an attribute,
otherwise defects in parsed messages will raise unexpected errors.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Policy.header_max_count">
<tt class="descname">header_max_count</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#email.policy.Policy.header_max_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum allowed number of headers named <em>name</em>.</p>
<p>Called when a header is added to a <a class="reference internal" href="email.message.html#email.message.Message" title="email.message.Message"><tt class="xref py py-class docutils literal"><span class="pre">Message</span></tt></a>
object.  If the returned value is not <tt class="docutils literal"><span class="pre">0</span></tt> or <tt class="docutils literal"><span class="pre">None</span></tt>, and there are
already a number of headers with the name <em>name</em> equal to the value
returned, a <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> is raised.</p>
<p>Because the default behavior of <tt class="docutils literal"><span class="pre">Message.__setitem__</span></tt> is to append the
value to the list of headers, it is easy to create duplicate headers
without realizing it.  This method allows certain headers to be limited
in the number of instances of that header that may be added to a
<tt class="docutils literal"><span class="pre">Message</span></tt> programmatically.  (The limit is not observed by the parser,
which will faithfully produce as many headers as exist in the message
being parsed.)</p>
<p>The default implementation returns <tt class="docutils literal"><span class="pre">None</span></tt> for all header names.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Policy.header_source_parse">
<tt class="descname">header_source_parse</tt><big>(</big><em>sourcelines</em><big>)</big><a class="headerlink" href="#email.policy.Policy.header_source_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>The email package calls this method with a list of strings, each string
ending with the line separation characters found in the source being
parsed.  The first line includes the field header name and separator.
All whitespace in the source is preserved.  The method should return the
<tt class="docutils literal"><span class="pre">(name,</span> <span class="pre">value)</span></tt> tuple that is to be stored in the <tt class="docutils literal"><span class="pre">Message</span></tt> to
represent the parsed header.</p>
<p>If an implementation wishes to retain compatibility with the existing
email package policies, <em>name</em> should be the case preserved name (all
characters up to the &#8216;<tt class="docutils literal"><span class="pre">:</span></tt>&#8216; separator), while <em>value</em> should be the
unfolded value (all line separator characters removed, but whitespace
kept intact), stripped of leading whitespace.</p>
<p><em>sourcelines</em> may contain surrogateescaped binary data.</p>
<p>There is no default implementation</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Policy.header_store_parse">
<tt class="descname">header_store_parse</tt><big>(</big><em>name</em>, <em>value</em><big>)</big><a class="headerlink" href="#email.policy.Policy.header_store_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>The email package calls this method with the name and value provided by
the application program when the application program is modifying a
<tt class="docutils literal"><span class="pre">Message</span></tt> programmatically (as opposed to a <tt class="docutils literal"><span class="pre">Message</span></tt> created by a
parser).  The method should return the <tt class="docutils literal"><span class="pre">(name,</span> <span class="pre">value)</span></tt> tuple that is to
be stored in the <tt class="docutils literal"><span class="pre">Message</span></tt> to represent the header.</p>
<p>If an implementation wishes to retain compatibility with the existing
email package policies, the <em>name</em> and <em>value</em> should be strings or
string subclasses that do not change the content of the passed in
arguments.</p>
<p>There is no default implementation</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Policy.header_fetch_parse">
<tt class="descname">header_fetch_parse</tt><big>(</big><em>name</em>, <em>value</em><big>)</big><a class="headerlink" href="#email.policy.Policy.header_fetch_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>The email package calls this method with the <em>name</em> and <em>value</em> currently
stored in the <tt class="docutils literal"><span class="pre">Message</span></tt> when that header is requested by the
application program, and whatever the method returns is what is passed
back to the application as the value of the header being retrieved.
Note that there may be more than one header with the same name stored in
the <tt class="docutils literal"><span class="pre">Message</span></tt>; the method is passed the specific name and value of the
header destined to be returned to the application.</p>
<p><em>value</em> may contain surrogateescaped binary data.  There should be no
surrogateescaped binary data in the value returned by the method.</p>
<p>There is no default implementation</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Policy.fold">
<tt class="descname">fold</tt><big>(</big><em>name</em>, <em>value</em><big>)</big><a class="headerlink" href="#email.policy.Policy.fold" title="Permalink to this definition">¶</a></dt>
<dd><p>The email package calls this method with the <em>name</em> and <em>value</em> currently
stored in the <tt class="docutils literal"><span class="pre">Message</span></tt> for a given header.  The method should return a
string that represents that header &#8220;folded&#8221; correctly (according to the
policy settings) by composing the <em>name</em> with the <em>value</em> and inserting
<a class="reference internal" href="#email.policy.Policy.linesep" title="email.policy.Policy.linesep"><tt class="xref py py-attr docutils literal"><span class="pre">linesep</span></tt></a> characters at the appropriate places.  See <span class="target" id="index-1"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>
for a discussion of the rules for folding email headers.</p>
<p><em>value</em> may contain surrogateescaped binary data.  There should be no
surrogateescaped binary data in the string returned by the method.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Policy.fold_binary">
<tt class="descname">fold_binary</tt><big>(</big><em>name</em>, <em>value</em><big>)</big><a class="headerlink" href="#email.policy.Policy.fold_binary" title="Permalink to this definition">¶</a></dt>
<dd><p>The same as <a class="reference internal" href="#email.policy.Policy.fold" title="email.policy.Policy.fold"><tt class="xref py py-meth docutils literal"><span class="pre">fold()</span></tt></a>, except that the returned value should be a
bytes object rather than a string.</p>
<p><em>value</em> may contain surrogateescaped binary data.  These could be
converted back into binary data in the returned bytes object.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="email.policy.Compat32">
<em class="property">class </em><tt class="descclassname">email.policy.</tt><tt class="descname">Compat32</tt><big>(</big><em>**kw</em><big>)</big><a class="headerlink" href="#email.policy.Compat32" title="Permalink to this definition">¶</a></dt>
<dd><p>This concrete <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><tt class="xref py py-class docutils literal"><span class="pre">Policy</span></tt></a> is the backward compatibility policy.  It
replicates the behavior of the email package in Python 3.2.  The
<a class="reference internal" href="#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><tt class="xref py py-mod docutils literal"><span class="pre">policy</span></tt></a> module also defines an instance of this class,
<tt class="xref py py-const docutils literal"><span class="pre">compat32</span></tt>, that is used as the default policy.  Thus the default
behavior of the email package is to maintain compatibility with Python 3.2.</p>
<p>The class provides the following concrete implementations of the
abstract methods of <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><tt class="xref py py-class docutils literal"><span class="pre">Policy</span></tt></a>:</p>
<dl class="method">
<dt id="email.policy.Compat32.header_source_parse">
<tt class="descname">header_source_parse</tt><big>(</big><em>sourcelines</em><big>)</big><a class="headerlink" href="#email.policy.Compat32.header_source_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>The name is parsed as everything up to the &#8216;<tt class="docutils literal"><span class="pre">:</span></tt>&#8216; and returned
unmodified.  The value is determined by stripping leading whitespace off
the remainder of the first line, joining all subsequent lines together,
and stripping any trailing carriage return or linefeed characters.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Compat32.header_store_parse">
<tt class="descname">header_store_parse</tt><big>(</big><em>name</em>, <em>value</em><big>)</big><a class="headerlink" href="#email.policy.Compat32.header_store_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>The name and value are returned unmodified.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Compat32.header_fetch_parse">
<tt class="descname">header_fetch_parse</tt><big>(</big><em>name</em>, <em>value</em><big>)</big><a class="headerlink" href="#email.policy.Compat32.header_fetch_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>If the value contains binary data, it is converted into a
<a class="reference internal" href="email.header.html#email.header.Header" title="email.header.Header"><tt class="xref py py-class docutils literal"><span class="pre">Header</span></tt></a> object using the <tt class="docutils literal"><span class="pre">unknown-8bit</span></tt> charset.
Otherwise it is returned unmodified.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Compat32.fold">
<tt class="descname">fold</tt><big>(</big><em>name</em>, <em>value</em><big>)</big><a class="headerlink" href="#email.policy.Compat32.fold" title="Permalink to this definition">¶</a></dt>
<dd><p>Headers are folded using the <a class="reference internal" href="email.header.html#email.header.Header" title="email.header.Header"><tt class="xref py py-class docutils literal"><span class="pre">Header</span></tt></a> folding
algorithm, which preserves existing line breaks in the value, and wraps
each resulting line to the <tt class="docutils literal"><span class="pre">max_line_length</span></tt>.  Non-ASCII binary data are
CTE encoded using the <tt class="docutils literal"><span class="pre">unknown-8bit</span></tt> charset.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.Compat32.fold_binary">
<tt class="descname">fold_binary</tt><big>(</big><em>name</em>, <em>value</em><big>)</big><a class="headerlink" href="#email.policy.Compat32.fold_binary" title="Permalink to this definition">¶</a></dt>
<dd><p>Headers are folded using the <a class="reference internal" href="email.header.html#email.header.Header" title="email.header.Header"><tt class="xref py py-class docutils literal"><span class="pre">Header</span></tt></a> folding
algorithm, which preserves existing line breaks in the value, and wraps
each resulting line to the <tt class="docutils literal"><span class="pre">max_line_length</span></tt>.  If <tt class="docutils literal"><span class="pre">cte_type</span></tt> is
<tt class="docutils literal"><span class="pre">7bit</span></tt>, non-ascii binary data is CTE encoded using the <tt class="docutils literal"><span class="pre">unknown-8bit</span></tt>
charset.  Otherwise the original source header is used, with its existing
line breaks and any (RFC invalid) binary data it may contain.</p>
</dd></dl>

</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The documentation below describes new policies that are included in the
standard library on a <a class="reference internal" href="../glossary.html#term-provisional-package"><em class="xref std std-term">provisional basis</em></a>.
Backwards incompatible changes (up to and including removal of the feature)
may occur if deemed necessary by the core developers.</p>
</div>
<dl class="class">
<dt id="email.policy.EmailPolicy">
<em class="property">class </em><tt class="descclassname">email.policy.</tt><tt class="descname">EmailPolicy</tt><big>(</big><em>**kw</em><big>)</big><a class="headerlink" href="#email.policy.EmailPolicy" title="Permalink to this definition">¶</a></dt>
<dd><p>This concrete <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><tt class="xref py py-class docutils literal"><span class="pre">Policy</span></tt></a> provides behavior that is intended to be fully
compliant with the current email RFCs.  These include (but are not limited
to) <span class="target" id="index-2"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>, <span class="target" id="index-3"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc2047.html"><strong>RFC 2047</strong></a>, and the current MIME RFCs.</p>
<p>This policy adds new header parsing and folding algorithms.  Instead of
simple strings, headers are <tt class="docutils literal"><span class="pre">str</span></tt> subclasses with attributes that depend
on the type of the field.  The parsing and folding algorithm fully implement
<span class="target" id="index-4"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc2047.html"><strong>RFC 2047</strong></a> and <span class="target" id="index-5"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a>.</p>
<p>In addition to the settable attributes listed above that apply to all
policies, this policy adds the following additional attributes:</p>
<dl class="attribute">
<dt id="email.policy.EmailPolicy.refold_source">
<tt class="descname">refold_source</tt><a class="headerlink" href="#email.policy.EmailPolicy.refold_source" title="Permalink to this definition">¶</a></dt>
<dd><p>If the value for a header in the <tt class="docutils literal"><span class="pre">Message</span></tt> object originated from a
<a class="reference internal" href="email.parser.html#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><tt class="xref py py-mod docutils literal"><span class="pre">parser</span></tt></a> (as opposed to being set by a program), this
attribute indicates whether or not a generator should refold that value
when transforming the message back into stream form.  The possible values
are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="89%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">none</span></tt></td>
<td>all source values use original folding</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">long</span></tt></td>
<td>source values that have any line that is longer than
<tt class="docutils literal"><span class="pre">max_line_length</span></tt> will be refolded</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">all</span></tt></td>
<td>all values are refolded.</td>
</tr>
</tbody>
</table>
<p>The default is <tt class="docutils literal"><span class="pre">long</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.EmailPolicy.header_factory">
<tt class="descname">header_factory</tt><a class="headerlink" href="#email.policy.EmailPolicy.header_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>A callable that takes two arguments, <tt class="docutils literal"><span class="pre">name</span></tt> and <tt class="docutils literal"><span class="pre">value</span></tt>, where
<tt class="docutils literal"><span class="pre">name</span></tt> is a header field name and <tt class="docutils literal"><span class="pre">value</span></tt> is an unfolded header field
value, and returns a string subclass that represents that header.  A
default <tt class="docutils literal"><span class="pre">header_factory</span></tt> (see <a class="reference internal" href="email.headerregistry.html#module-email.headerregistry" title="email.headerregistry: Automatic Parsing of headers based on the field name"><tt class="xref py py-mod docutils literal"><span class="pre">headerregistry</span></tt></a>) is provided
that understands some of the <span class="target" id="index-6"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc5322.html"><strong>RFC 5322</strong></a> header field types.  (Currently
address fields and date fields have special treatment, while all other
fields are treated as unstructured.  This list will be completed before
the extension is marked stable.)</p>
</dd></dl>

<dl class="attribute">
<dt id="email.policy.EmailPolicy.content_manager">
<tt class="descname">content_manager</tt><a class="headerlink" href="#email.policy.EmailPolicy.content_manager" title="Permalink to this definition">¶</a></dt>
<dd><p>An object with at least two methods: get_content and set_content.  When
the <tt class="xref py py-meth docutils literal"><span class="pre">get_content()</span></tt> or
<tt class="xref py py-meth docutils literal"><span class="pre">set_content()</span></tt> method of a
<a class="reference internal" href="email.message.html#email.message.Message" title="email.message.Message"><tt class="xref py py-class docutils literal"><span class="pre">Message</span></tt></a> object is called, it calls the
corresponding method of this object, passing it the message object as its
first argument, and any arguments or keywords that were passed to it as
additional arguments.  By default <tt class="docutils literal"><span class="pre">content_manager</span></tt> is set to
<a class="reference internal" href="email.contentmanager.html#email.contentmanager.raw_data_manager" title="email.contentmanager.raw_data_manager"><tt class="xref py py-data docutils literal"><span class="pre">raw_data_manager</span></tt></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.4.</span></p>
</div>
</dd></dl>

<p>The class provides the following concrete implementations of the abstract
methods of <a class="reference internal" href="#email.policy.Policy" title="email.policy.Policy"><tt class="xref py py-class docutils literal"><span class="pre">Policy</span></tt></a>:</p>
<dl class="method">
<dt id="email.policy.EmailPolicy.header_max_count">
<tt class="descname">header_max_count</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#email.policy.EmailPolicy.header_max_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the
<a class="reference internal" href="email.headerregistry.html#email.headerregistry.BaseHeader.max_count" title="email.headerregistry.BaseHeader.max_count"><tt class="xref py py-attr docutils literal"><span class="pre">max_count</span></tt></a> attribute of the
specialized class used to represent the header with the given name.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.EmailPolicy.header_source_parse">
<tt class="descname">header_source_parse</tt><big>(</big><em>sourcelines</em><big>)</big><a class="headerlink" href="#email.policy.EmailPolicy.header_source_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>The implementation of this method is the same as that for the
<a class="reference internal" href="#email.policy.Compat32" title="email.policy.Compat32"><tt class="xref py py-class docutils literal"><span class="pre">Compat32</span></tt></a> policy.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.EmailPolicy.header_store_parse">
<tt class="descname">header_store_parse</tt><big>(</big><em>name</em>, <em>value</em><big>)</big><a class="headerlink" href="#email.policy.EmailPolicy.header_store_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>The name is returned unchanged.  If the input value has a <tt class="docutils literal"><span class="pre">name</span></tt>
attribute and it matches <em>name</em> ignoring case, the value is returned
unchanged.  Otherwise the <em>name</em> and <em>value</em> are passed to
<tt class="docutils literal"><span class="pre">header_factory</span></tt>, and the resulting header object is returned as
the value.  In this case a <tt class="docutils literal"><span class="pre">ValueError</span></tt> is raised if the input value
contains CR or LF characters.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.EmailPolicy.header_fetch_parse">
<tt class="descname">header_fetch_parse</tt><big>(</big><em>name</em>, <em>value</em><big>)</big><a class="headerlink" href="#email.policy.EmailPolicy.header_fetch_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>If the value has a <tt class="docutils literal"><span class="pre">name</span></tt> attribute, it is returned to unmodified.
Otherwise the <em>name</em>, and the <em>value</em> with any CR or LF characters
removed, are passed to the <tt class="docutils literal"><span class="pre">header_factory</span></tt>, and the resulting
header object is returned.  Any surrogateescaped bytes get turned into
the unicode unknown-character glyph.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.EmailPolicy.fold">
<tt class="descname">fold</tt><big>(</big><em>name</em>, <em>value</em><big>)</big><a class="headerlink" href="#email.policy.EmailPolicy.fold" title="Permalink to this definition">¶</a></dt>
<dd><p>Header folding is controlled by the <a class="reference internal" href="#email.policy.EmailPolicy.refold_source" title="email.policy.EmailPolicy.refold_source"><tt class="xref py py-attr docutils literal"><span class="pre">refold_source</span></tt></a> policy setting.
A value is considered to be a &#8216;source value&#8217; if and only if it does not
have a <tt class="docutils literal"><span class="pre">name</span></tt> attribute (having a <tt class="docutils literal"><span class="pre">name</span></tt> attribute means it is a
header object of some sort).  If a source value needs to be refolded
according to the policy, it is converted into a header object by
passing the <em>name</em> and the <em>value</em> with any CR and LF characters removed
to the <tt class="docutils literal"><span class="pre">header_factory</span></tt>.  Folding of a header object is done by
calling its <tt class="docutils literal"><span class="pre">fold</span></tt> method with the current policy.</p>
<p>Source values are split into lines using <a class="reference internal" href="stdtypes.html#str.splitlines" title="str.splitlines"><tt class="xref py py-meth docutils literal"><span class="pre">splitlines()</span></tt></a>.  If
the value is not to be refolded, the lines are rejoined using the
<tt class="docutils literal"><span class="pre">linesep</span></tt> from the policy and returned.  The exception is lines
containing non-ascii binary data.  In that case the value is refolded
regardless of the <tt class="docutils literal"><span class="pre">refold_source</span></tt> setting, which causes the binary data
to be CTE encoded using the <tt class="docutils literal"><span class="pre">unknown-8bit</span></tt> charset.</p>
</dd></dl>

<dl class="method">
<dt id="email.policy.EmailPolicy.fold_binary">
<tt class="descname">fold_binary</tt><big>(</big><em>name</em>, <em>value</em><big>)</big><a class="headerlink" href="#email.policy.EmailPolicy.fold_binary" title="Permalink to this definition">¶</a></dt>
<dd><p>The same as <a class="reference internal" href="#email.policy.EmailPolicy.fold" title="email.policy.EmailPolicy.fold"><tt class="xref py py-meth docutils literal"><span class="pre">fold()</span></tt></a> if <a class="reference internal" href="#email.policy.Policy.cte_type" title="email.policy.Policy.cte_type"><tt class="xref py py-attr docutils literal"><span class="pre">cte_type</span></tt></a> is <tt class="docutils literal"><span class="pre">7bit</span></tt>, except
that the returned value is bytes.</p>
<p>If <a class="reference internal" href="#email.policy.Policy.cte_type" title="email.policy.Policy.cte_type"><tt class="xref py py-attr docutils literal"><span class="pre">cte_type</span></tt></a> is <tt class="docutils literal"><span class="pre">8bit</span></tt>, non-ASCII binary data is
converted back
into bytes.  Headers with binary data are not refolded, regardless of the
<tt class="docutils literal"><span class="pre">refold_header</span></tt> setting, since there is no way to know whether the
binary data consists of single byte characters or multibyte characters.</p>
</dd></dl>

</dd></dl>

<p>The following instances of <a class="reference internal" href="#email.policy.EmailPolicy" title="email.policy.EmailPolicy"><tt class="xref py py-class docutils literal"><span class="pre">EmailPolicy</span></tt></a> provide defaults suitable for
specific application domains.  Note that in the future the behavior of these
instances (in particular the <tt class="docutils literal"><span class="pre">HTTP</span></tt> instance) may be adjusted to conform even
more closely to the RFCs relevant to their domains.</p>
<dl class="data">
<dt id="email.policy.default">
<tt class="descclassname">email.policy.</tt><tt class="descname">default</tt><a class="headerlink" href="#email.policy.default" title="Permalink to this definition">¶</a></dt>
<dd><p>An instance of <tt class="docutils literal"><span class="pre">EmailPolicy</span></tt> with all defaults unchanged.  This policy
uses the standard Python <tt class="docutils literal"><span class="pre">\n</span></tt> line endings rather than the RFC-correct
<tt class="docutils literal"><span class="pre">\r\n</span></tt>.</p>
</dd></dl>

<dl class="data">
<dt id="email.policy.SMTP">
<tt class="descclassname">email.policy.</tt><tt class="descname">SMTP</tt><a class="headerlink" href="#email.policy.SMTP" title="Permalink to this definition">¶</a></dt>
<dd><p>Suitable for serializing messages in conformance with the email RFCs.
Like <tt class="docutils literal"><span class="pre">default</span></tt>, but with <tt class="docutils literal"><span class="pre">linesep</span></tt> set to <tt class="docutils literal"><span class="pre">\r\n</span></tt>, which is RFC
compliant.</p>
</dd></dl>

<dl class="data">
<dt id="email.policy.HTTP">
<tt class="descclassname">email.policy.</tt><tt class="descname">HTTP</tt><a class="headerlink" href="#email.policy.HTTP" title="Permalink to this definition">¶</a></dt>
<dd><p>Suitable for serializing headers with for use in HTTP traffic.  Like
<tt class="docutils literal"><span class="pre">SMTP</span></tt> except that <tt class="docutils literal"><span class="pre">max_line_length</span></tt> is set to <tt class="docutils literal"><span class="pre">None</span></tt> (unlimited).</p>
</dd></dl>

<dl class="data">
<dt id="email.policy.strict">
<tt class="descclassname">email.policy.</tt><tt class="descname">strict</tt><a class="headerlink" href="#email.policy.strict" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience instance.  The same as <tt class="docutils literal"><span class="pre">default</span></tt> except that
<tt class="docutils literal"><span class="pre">raise_on_defect</span></tt> is set to <tt class="docutils literal"><span class="pre">True</span></tt>.  This allows any policy to be made
strict by writing:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="n">somepolicy</span> <span class="o">+</span> <span class="n">policy</span><span class="o">.</span><span class="n">strict</span>
</pre></div>
</div>
</dd></dl>

<p>With all of these <a class="reference internal" href="#email.policy.EmailPolicy" title="email.policy.EmailPolicy"><tt class="xref py py-class docutils literal"><span class="pre">EmailPolicies</span></tt></a>, the effective API of
the email package is changed from the Python 3.2 API in the following ways:</p>
<blockquote>
<div><ul class="simple">
<li>Setting a header on a <a class="reference internal" href="email.message.html#email.message.Message" title="email.message.Message"><tt class="xref py py-class docutils literal"><span class="pre">Message</span></tt></a> results in that
header being parsed and a header object created.</li>
<li>Fetching a header value from a <a class="reference internal" href="email.message.html#email.message.Message" title="email.message.Message"><tt class="xref py py-class docutils literal"><span class="pre">Message</span></tt></a> results
in that header being parsed and a header object created and
returned.</li>
<li>Any header object, or any header that is refolded due to the
policy settings, is folded using an algorithm that fully implements the
RFC folding algorithms, including knowing where encoded words are required
and allowed.</li>
</ul>
</div></blockquote>
<p>From the application view, this means that any header obtained through the
<a class="reference internal" href="email.message.html#email.message.Message" title="email.message.Message"><tt class="xref py py-class docutils literal"><span class="pre">Message</span></tt></a> is a header object with extra
attributes, whose string value is the fully decoded unicode value of the
header.  Likewise, a header may be assigned a new value, or a new header
created, using a unicode string, and the policy will take care of converting
the unicode string into the correct RFC encoded form.</p>
<p>The header objects and their attributes are described in
<a class="reference internal" href="email.headerregistry.html#module-email.headerregistry" title="email.headerregistry: Automatic Parsing of headers based on the field name"><tt class="xref py py-mod docutils literal"><span class="pre">headerregistry</span></tt></a>.</p>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="email.generator.html"
                        title="previous chapter">19.1.3. <tt class="docutils literal"><span class="pre">email.generator</span></tt>: Generating MIME documents</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="email.headerregistry.html"
                        title="next chapter">19.1.5. <tt class="docutils literal"><span class="pre">email.headerregistry</span></tt>: Custom Header Objects</a></p>
<h3>This Page</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">Report a Bug</a></li>
  <li><a href="../_sources/library/email.policy.txt"
         rel="nofollow">Show Source</a></li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="email.headerregistry.html" title="19.1.5. email.headerregistry: Custom Header Objects"
             >next</a> |</li>
        <li class="right" >
          <a href="email.generator.html" title="19.1.3. email.generator: Generating MIME documents"
             >previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &raquo;</li>
        <li>
          <span class="version_switcher_placeholder">3.4.3</span>
          <a href="../index.html">Documentation</a> &raquo;
        </li>

          <li><a href="index.html" >The Python Standard Library</a> &raquo;</li>
          <li><a href="netdata.html" >19. Internet Data Handling</a> &raquo;</li>
          <li><a href="email.html" >19.1. <tt class="docutils literal"><span class="pre">email</span></tt> &#8212; An email and MIME handling package</a> &raquo;</li> 
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2015, Python Software Foundation.
    <br />
    The Python Software Foundation is a non-profit corporation.
    <a href="https://www.python.org/psf/donations/">Please donate.</a>
    <br />
    Last updated on Feb 26, 2015.
    <a href="../bugs.html">Found a bug</a>?
    <br />
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.3.
    </div>

  </body>
</html>